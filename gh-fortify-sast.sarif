{
  "$schema" : "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
  "version" : "2.1.0",
  "runs" : [ {
    "tool" : {
      "driver" : {
        "name" : "Fortify SCA",
        "version" : "22.1.0.0166",
        "rules" : [ {
          "id" : "4344",
          "shortDescription" : {
            "text" : "Dockerfile Misconfiguration: Default User Privilege"
          },
          "fullDescription" : {
            "text" : "The Dockerfile does not specify a USER, so it defaults to running with a root user.\n\n\n"
          },
          "help" : {
            "text" : "When a Dockerfile does not specify a USER, Docker containers run with super user privileges by default. These super user privileges are propagated to the code running inside the container, which is usually more permission than necessary. Running the Docker container with super user privileges broadens the attack surface which might enable attackers to perform more serious forms of exploitation.\n\nIt is good practice to run your containers as a non-root user when possible.\n\nTo modify a docker container to use a non-root user, the Dockerfile needs to specify a different user, such as:\n\nRUN useradd myLowPrivilegeUser\nUSER myLowPrivilegeUser\n\n    \n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4344/?engineType=SCA&issue=C30558D67920422BF94AC1350B33CF49"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "4333",
          "shortDescription" : {
            "text" : "Password Management: Hardcoded Password"
          },
          "fullDescription" : {
            "text" : "Hardcoded passwords can compromise system security in a way that is difficult to remedy.\n\n\n"
          },
          "help" : {
            "text" : "Never hardcode passwords. Not only does it expose the password to all of the project's developers, it also makes fixing the problem extremely difficult. After the code is in production, a program patch is probably the only way to change the password. If the account the password protects is compromised, the system owners must choose between security and availability.\n\nA password was configured to access a resource in docker-compose.yml on line 7.\n\n\nExample: The following YAML uses a hardcoded password:\n\n\n...\ncredential_settings:\n  username: scott\n  password: tiger\n...\n\n\nThis configuration may be valid, but anyone who has access to the configuration will have access to the password. After the program is released, changing the default user account \"scott\" with a password of \"tiger\" is difficult. Anyone with access to this information can use it to break into the system.\n\nNever hardcode password. Passwords should generally be obfuscated and managed in an external source. Storing passwords in plain text anywhere on the system allows anyone with sufficient permissions to read and potentially misuse the password.\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4333/?engineType=SCA&issue=A1A174E0B163082FF1E5CA9CC2180B96"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "4334",
          "shortDescription" : {
            "text" : "Password Management: Hardcoded Password"
          },
          "fullDescription" : {
            "text" : "Hardcoded passwords can compromise system security in a way that is difficult to remedy.\n\n\n"
          },
          "help" : {
            "text" : "Never hardcode passwords. Not only does it expose the password to all of the project's developers, it also makes fixing the problem extremely difficult. After the code is in production, a program patch is probably the only way to change the password. If the account the password protects is compromised, the system owners must choose between security and availability.\n\nA password was configured to access a resource in docker-compose.yml on line 16.\n\n\nExample: The following YAML uses a hardcoded password:\n\n\n...\ncredential_settings:\n  username: scott\n  password: tiger\n...\n\n\nThis configuration may be valid, but anyone who has access to the configuration will have access to the password. After the program is released, changing the default user account \"scott\" with a password of \"tiger\" is difficult. Anyone with access to this information can use it to break into the system.\n\nNever hardcode password. Passwords should generally be obfuscated and managed in an external source. Storing passwords in plain text anywhere on the system allows anyone with sufficient permissions to read and potentially misuse the password.\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4334/?engineType=SCA&issue=A1A174E0B163082FF1E5CA9CC2180B97"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "4326",
          "shortDescription" : {
            "text" : "Build Misconfiguration: External Maven Dependency Repository"
          },
          "fullDescription" : {
            "text" : "This maven build script relies on external sources, which could allow an attacker to insert malicious code into the final product or to take control of the build machine.\n\n\n"
          },
          "help" : {
            "text" : "Several tools exist within the Java development world to aid in dependency management: both Apache Ant and Apache Maven build systems include functionality specifically designed to help manage dependencies and Apache Ivy is developed explicitly as a dependency manager. Although there are differences in their behavior, these tools share the common functionality that they automatically download external dependencies specified in the build process at build time. This makes it much easier for developer B to build software in the same manner as developer A. Developers just store dependency information in the build file, which means that each developer and build engineer has a consistent way to obtain dependencies, compile the code, and deploy without the dependency management hassles involved in manual dependency management. The following examples illustrate how Ivy, Ant, and Maven can be used to manage external dependencies as part of a build process.\n\nUnder Maven, instead of listing explicit URLs from which to retrieve the dependencies, developers specify the dependency names and versions and Maven relies on its underlying configuration to identify the server(s) from which to retrieve the dependencies. For commonly used components this saves the developer from having to researching dependency locations.\n\nExample 1: The following excerpt from a Maven pom.xml file shows how a developer can specify multiple external dependencies using their name and version:\n\n\n&lt;dependencies&gt;\n  &lt;dependency&gt;\n    &lt;groupId&gt;commons-logging&lt;/groupId&gt;\n    &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;\n    &lt;version&gt;1.1&lt;/version&gt;\n  &lt;/dependency&gt;\n  &lt;dependency&gt;\n    &lt;groupId&gt;javax.jms&lt;/groupId&gt;\n    &lt;artifactId&gt;jms&lt;/artifactId&gt;\n    &lt;version&gt;1.1&lt;/version&gt;\n  &lt;/dependency&gt;\n  ...\n&lt;/dependencies&gt;\n\n\nTwo distinct types of attack scenarios affect these systems: An attacker could either compromise the server hosting the dependency or compromise the DNS server the build machine uses to redirect requests for hostname of the server hosting the dependency to a machine controlled by the attacker. Both scenarios result in the attacker gaining the ability to inject a malicious version of a dependency into a build running on an otherwise uncompromised machine.\n\nRegardless of the attack vector used to deliver the Trojan dependency, these scenarios share the common element that the build system blindly accepts the malicious binary and includes it in the build. Because the build system has no recourse for rejecting the malicious binary and existing security mechanisms, such as code review, typically focus on internally-developed code rather than external dependencies, this type of attack has a strong potential to go unnoticed as it spreads through the development environment and potentially into production.\n\nAlthough there is some risk of a compromised dependency being introduced into a manual build process, by the tendency of automated build systems to retrieve the dependency from an external source each time the build system is run in a new environment greatly increases the window of opportunity for an attacker. An attacker need only compromise the dependency server or the DNS server during one of the many times the dependency is retrieved in order to compromise the machine on which the build is occurring.\n\nThe simplest solution is to refrain from adopting automated dependency management systems altogether. Managing dependencies manually eliminates the potential for unexpected behavior caused by the build system. Obviously, an attacker could still mount one of the attacks described previously to coincide with the manual retrieval of a dependency, but limiting the frequency with which the dependency must be retrieved significantly reduces the window of opportunity for an attacker. Finally, this solution forces the development organization to rely on what is ostensibly an antiquated build system. A system based on manual dependency management is often more difficult to use and maintain, and might be unacceptable in some software development environments.\n\nThe second solution is a hybrid of the traditional manual dependency management approach and the fully automated solution that is popular today. The biggest advantage of the manual build process is the decreased window of attack, which can be achieved in a semi-automated system by replicating external dependency servers internally. Any build system that requires an external dependency can then point to the internal server using a hard-coded internal IP address to bypass the risk of DNS-based attacks. As new dependencies are added and new versions released, they can be downloaded once and included on the internal repository. This solution reduces the attack opportunities and allows the organization leverage existing internal network security infrastructure.\n\nTo implement this solution using Maven, a project should have the IP address for an internal repository hard coded the pom.xml. Specifying the IP address in the pom.xml ensures the internal repository will be used by the corresponding build, but is tied to a specific project. Alternatively, the IP address can be specified in settings.xml, which makes the configuration easier to share across multiple projects.\n\nExample 2: The following Maven pom.xml demonstrates the use of an explicit internal IP address (the entries can also be used in settings.xml):\n\n\n&lt;project&gt;\n  ...\n  &lt;repositories&gt;\n    &lt;repository&gt;\n      &lt;releases&gt;\n        &lt;enabled&gt;true&lt;/enabled&gt;\n        &lt;updatePolicy&gt;always&lt;/updatePolicy&gt;\n        &lt;checksumPolicy&gt;warn&lt;/checksumPolicy&gt;\n      &lt;/releases&gt;\n      &lt;snapshots&gt;\n        &lt;enabled&gt;true&lt;/enabled&gt;\n        &lt;updatePolicy&gt;never&lt;/updatePolicy&gt;\n        &lt;checksumPolicy&gt;fail&lt;/checksumPolicy&gt;\n      &lt;/snapshots&gt;\n      &lt;id&gt;central&lt;/id&gt;\n      &lt;name&gt;Internal Repository&lt;/name&gt;\n      &lt;url&gt;http://172.16.1.13/maven2&lt;/url&gt;\n      &lt;layout&gt;default&lt;/layout&gt;\n    &lt;/repository&gt;\n  &lt;/repositories&gt;\n  &lt;pluginRepositories&gt;\n    ...\n  &lt;/pluginRepositories&gt;\n  ...\n&lt;/project&gt;\n\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4326/?engineType=SCA&issue=87E3EC5CC8154C006783CC461A6DDEEB"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4327",
          "shortDescription" : {
            "text" : "System Information Leak: Struts 2"
          },
          "fullDescription" : {
            "text" : "Revealing system data or debugging information helps an adversary learn about the system and form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debug information leaves the program through an output stream or logging function.\n\nIn this case, the Struts 2 Config Browser is configured in the maven pom.xml file and so it is available and deployed along the application.\n\nThe Config Browser plugin is a debugging tool to help view an application's configuration at runtime. It is very useful when debugging problems that could be related to configuration issues but it exposes too many details that may help an attacker to map and model the application.\n\nConfig Browser should not be deployed on production environments.\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4327/?engineType=SCA&issue=8A3F2FE7439259154AADB746A911E394"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4330",
          "shortDescription" : {
            "text" : "Struts 2: Unvalidated Action"
          },
          "fullDescription" : {
            "text" : "Struts2 Actions should utilize the Struts Validation framework to prevent vulnerabilities that result from unchecked input.\n\n\n"
          },
          "help" : {
            "text" : "Unchecked input is the leading cause of vulnerabilities in J2EE applications. Unchecked input can lead to numerous vulnerabilities, including cross-site scripting, process control, and SQL injection. Although J2EE applications are not generally susceptible to memory corruption attacks, if a J2EE application interfaces with native code that does not perform array bounds checking, an attacker may be able to use an input validation mistake in the J2EE application to launch a buffer overflow attack.\n\nTo prevent such attacks, use the Struts Validation framework to check all program input before it is processed by the application. Use Fortify Static Code Analyzer to ensure that there are no holes in your configuration of the Struts Validator.\n\nExample uses of the validator include checking to ensure that:\n\n- Phone number fields contain only valid characters in phone numbers\n\n- Boolean values are only \"T\" or \"F\"\n\n- Free-form strings are of a reasonable length and composition\n\nDefine a Struts Validator for the corresponding Action. An example of a typical \"ActionClass-validation.xml\" setup is:\n\n&lt;validators&gt;\n  &lt;field name=\"user.firstName\"&gt;\n    &lt;field-validator type=\"requiredstring\"&gt;\n      &lt;message key=\"user.firstName.empty\"/&gt;\n    &lt;/field-validator&gt;\n  &lt;/field&gt;\n...\n\nThe configuration file ActionClass-validation.xml contains the definitions of validation functions, called validators.\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4330/?engineType=SCA&issue=91EB85F977247B89E4C347CCDC9B7C9E"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4358",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function renderText() in BaseController.java reveals system data or debug information by calling printStackTrace() on line 62. The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debug information leaves the program through an output stream or logging function.\n\n\nIn this case, printStackTrace() is called in BaseController.java on line 62.\n\n\nExample 1: The following code writes an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. For example, with scripting mechanisms it is trivial to redirect output information from \"Standard error\" or \"Standard output\" into a file or another program. Alternatively, the system that the program runs on could have a remote logging mechanism such as a \"syslog\" server that sends the logs to a remote device. During development, you have no way of knowing where this information might end up being displayed.\n\nIn some cases, the error message provides the attacker with the precise type of attack to which the system is vulnerable. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In Example 1, the leaked information could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\nHere is another scenario, specific to the mobile world. Most mobile devices now implement a Near-Field Communication (NFC) protocol for quickly sharing information between devices using radio communication. It works by bringing devices to close proximity or simply having them touch each other. Even though the communication range of NFC is limited to just a few centimeters, eavesdropping, data modification and various other types of attacks are possible, since NFC alone does not ensure secure communication.\n\nExample 2: The Android platform provides support for NFC. The following code creates a message that gets pushed to the other device within the range.\n\n...\npublic static final String TAG = \"NfcActivity\";\nprivate static final String DATA_SPLITTER = \"__:DATA:__\";\nprivate static final String MIME_TYPE = \"application/my.applications.mimetype\";\n...\npublic NdefMessage createNdefMessage(NfcEvent event) {\n    TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);\n    String VERSION = tm.getDeviceSoftwareVersion();\n    String text = TAG + DATA_SPLITTER + VERSION;\n    NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,\n            MIME_TYPE.getBytes(), new byte[0], text.getBytes());\n    NdefRecord[] records = { record };\n    NdefMessage msg = new NdefMessage(records);\n    return msg;\n}\n...\n\n\nNFC Data Exchange Format (NDEF) message contains typed data, a URI, or a custom application payload. If the message contains information about the application, such as its name, MIME type, or device software version, this information could be leaked to an eavesdropper. In Example 2, Fortify Static Code Analyzer reports a System Information Leak vulnerability on the return statement.\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Debug traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\nIf you are concerned about leaking system data via NFC on an Android device, you could do one of the following three things. Do not include system data in the messages pushed to other devices in range, encrypt the payload of the message, or establish a secure communication channel at a higher layer.\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4358/?engineType=SCA&issue=FD12FE6FC705F7DEEFC8029D24CA1A81"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4336",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function renderJSON() in BaseController.java reveals system data or debug information by calling printStackTrace() on line 75. The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debug information leaves the program through an output stream or logging function.\n\n\nIn this case, printStackTrace() is called in BaseController.java on line 75.\n\n\nExample 1: The following code writes an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. For example, with scripting mechanisms it is trivial to redirect output information from \"Standard error\" or \"Standard output\" into a file or another program. Alternatively, the system that the program runs on could have a remote logging mechanism such as a \"syslog\" server that sends the logs to a remote device. During development, you have no way of knowing where this information might end up being displayed.\n\nIn some cases, the error message provides the attacker with the precise type of attack to which the system is vulnerable. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In Example 1, the leaked information could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\nHere is another scenario, specific to the mobile world. Most mobile devices now implement a Near-Field Communication (NFC) protocol for quickly sharing information between devices using radio communication. It works by bringing devices to close proximity or simply having them touch each other. Even though the communication range of NFC is limited to just a few centimeters, eavesdropping, data modification and various other types of attacks are possible, since NFC alone does not ensure secure communication.\n\nExample 2: The Android platform provides support for NFC. The following code creates a message that gets pushed to the other device within the range.\n\n...\npublic static final String TAG = \"NfcActivity\";\nprivate static final String DATA_SPLITTER = \"__:DATA:__\";\nprivate static final String MIME_TYPE = \"application/my.applications.mimetype\";\n...\npublic NdefMessage createNdefMessage(NfcEvent event) {\n    TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);\n    String VERSION = tm.getDeviceSoftwareVersion();\n    String text = TAG + DATA_SPLITTER + VERSION;\n    NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,\n            MIME_TYPE.getBytes(), new byte[0], text.getBytes());\n    NdefRecord[] records = { record };\n    NdefMessage msg = new NdefMessage(records);\n    return msg;\n}\n...\n\n\nNFC Data Exchange Format (NDEF) message contains typed data, a URI, or a custom application payload. If the message contains information about the application, such as its name, MIME type, or device software version, this information could be leaked to an eavesdropper. In Example 2, Fortify Static Code Analyzer reports a System Information Leak vulnerability on the return statement.\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Debug traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\nIf you are concerned about leaking system data via NFC on an Android device, you could do one of the following three things. Do not include system data in the messages pushed to other devices in range, encrypt the payload of the message, or establish a secure communication channel at a higher layer.\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4336/?engineType=SCA&issue=A64622E544ACEF0FF2CBC91A944348D5"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4346",
          "shortDescription" : {
            "text" : "Struts 2: Unvalidated Action"
          },
          "fullDescription" : {
            "text" : "Struts2 Actions should utilize the Struts Validation framework to prevent vulnerabilities that result from unchecked input.\n\n\n"
          },
          "help" : {
            "text" : "Unchecked input is the leading cause of vulnerabilities in J2EE applications. Unchecked input can lead to numerous vulnerabilities, including cross-site scripting, process control, and SQL injection. Although J2EE applications are not generally susceptible to memory corruption attacks, if a J2EE application interfaces with native code that does not perform array bounds checking, an attacker may be able to use an input validation mistake in the J2EE application to launch a buffer overflow attack.\n\nTo prevent such attacks, use the Struts Validation framework to check all program input before it is processed by the application. Use Fortify Static Code Analyzer to ensure that there are no holes in your configuration of the Struts Validator.\n\nExample uses of the validator include checking to ensure that:\n\n- Phone number fields contain only valid characters in phone numbers\n\n- Boolean values are only \"T\" or \"F\"\n\n- Free-form strings are of a reasonable length and composition\n\nDefine a Struts Validator for the corresponding Action. An example of a typical \"ActionClass-validation.xml\" setup is:\n\n&lt;validators&gt;\n  &lt;field name=\"user.firstName\"&gt;\n    &lt;field-validator type=\"requiredstring\"&gt;\n      &lt;message key=\"user.firstName.empty\"/&gt;\n    &lt;/field-validator&gt;\n  &lt;/field&gt;\n...\n\nThe configuration file ActionClass-validation.xml contains the definitions of validation functions, called validators.\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4346/?engineType=SCA&issue=C4FDB000933A03F4805D7E23391F9A7E"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4311",
          "shortDescription" : {
            "text" : "Struts 2: Action Field Without Validator"
          },
          "fullDescription" : {
            "text" : "An Action Field was found without a corresponding validation definition.\n\n\n"
          },
          "help" : {
            "text" : "One or more Action Fields do not have a corresponding validation definition. Each field should have an explicit validation routine referenced in ActionClass-validation.xml.\n\nIt is easy for developers to forget to update validation logic when they remove or rename action form mappings. One indication that validation logic is not being properly maintained is the lack of a validator definition.\n\nIt is critically important that validation logic be maintained and kept in sync with the rest of the application. Unchecked input is the root cause of some of today's worst and most common software security problems. Cross-site scripting, SQL injection, and process control vulnerabilities all stem from incomplete or absent input validation. Although J2EE applications are not generally susceptible to memory corruption attacks, if a J2EE application interfaces with native code that does not perform array bounds checking, an attacker may be able to use an input validation mistake in the J2EE application to launch a buffer overflow attack.\n\nExamine the action validation file and search for possible matches for the orphaned validation definition. This result may indicate that an Action field has been renamed without the corresponding validation being updated.\n\nLook for other, perhaps more subtle, problems with the validation logic.\n\n- If the validation definition was previously used by an action form mapping that has\nsince been deleted, delete the unused validation form.\n\n- If the action form mapping has been renamed, consider renaming the validation\nfile so that the two are once again linked.\n\n- If the functionality present in the old action form mapping has been merged into\nanother action form mapping, check the unused validation logic against the new\nvalidation logic for consistency.\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4311/?engineType=SCA&issue=39F250AE15CAC387EDD5C941ECCA7EA1"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4303",
          "shortDescription" : {
            "text" : "Struts 2: Action Field Without Validator"
          },
          "fullDescription" : {
            "text" : "An Action Field was found without a corresponding validation definition.\n\n\n"
          },
          "help" : {
            "text" : "One or more Action Fields do not have a corresponding validation definition. Each field should have an explicit validation routine referenced in ActionClass-validation.xml.\n\nIt is easy for developers to forget to update validation logic when they remove or rename action form mappings. One indication that validation logic is not being properly maintained is the lack of a validator definition.\n\nIt is critically important that validation logic be maintained and kept in sync with the rest of the application. Unchecked input is the root cause of some of today's worst and most common software security problems. Cross-site scripting, SQL injection, and process control vulnerabilities all stem from incomplete or absent input validation. Although J2EE applications are not generally susceptible to memory corruption attacks, if a J2EE application interfaces with native code that does not perform array bounds checking, an attacker may be able to use an input validation mistake in the J2EE application to launch a buffer overflow attack.\n\nExamine the action validation file and search for possible matches for the orphaned validation definition. This result may indicate that an Action field has been renamed without the corresponding validation being updated.\n\nLook for other, perhaps more subtle, problems with the validation logic.\n\n- If the validation definition was previously used by an action form mapping that has\nsince been deleted, delete the unused validation form.\n\n- If the action form mapping has been renamed, consider renaming the validation\nfile so that the two are once again linked.\n\n- If the functionality present in the old action form mapping has been merged into\nanother action form mapping, check the unused validation logic against the new\nvalidation logic for consistency.\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4303/?engineType=SCA&issue=1C9ECCFE853A32DD09D4BBAA03565655"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4316",
          "shortDescription" : {
            "text" : "Struts 2: Unvalidated Action"
          },
          "fullDescription" : {
            "text" : "Struts2 Actions should utilize the Struts Validation framework to prevent vulnerabilities that result from unchecked input.\n\n\n"
          },
          "help" : {
            "text" : "Unchecked input is the leading cause of vulnerabilities in J2EE applications. Unchecked input can lead to numerous vulnerabilities, including cross-site scripting, process control, and SQL injection. Although J2EE applications are not generally susceptible to memory corruption attacks, if a J2EE application interfaces with native code that does not perform array bounds checking, an attacker may be able to use an input validation mistake in the J2EE application to launch a buffer overflow attack.\n\nTo prevent such attacks, use the Struts Validation framework to check all program input before it is processed by the application. Use Fortify Static Code Analyzer to ensure that there are no holes in your configuration of the Struts Validator.\n\nExample uses of the validator include checking to ensure that:\n\n- Phone number fields contain only valid characters in phone numbers\n\n- Boolean values are only \"T\" or \"F\"\n\n- Free-form strings are of a reasonable length and composition\n\nDefine a Struts Validator for the corresponding Action. An example of a typical \"ActionClass-validation.xml\" setup is:\n\n&lt;validators&gt;\n  &lt;field name=\"user.firstName\"&gt;\n    &lt;field-validator type=\"requiredstring\"&gt;\n      &lt;message key=\"user.firstName.empty\"/&gt;\n    &lt;/field-validator&gt;\n  &lt;/field&gt;\n...\n\nThe configuration file ActionClass-validation.xml contains the definitions of validation functions, called validators.\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4316/?engineType=SCA&issue=5524969D03F1852D9793B193974B507F"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4320",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at PingAction.java line 36 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get repetitive, but \"condensing\" catch blocks by catching a high-level class such as Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes such as Exception, Throwable, Error, or RuntimeException except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4320/?engineType=SCA&issue=5E6159E0C738CB312E011A8545947D3C"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4317",
          "shortDescription" : {
            "text" : "Command Injection"
          },
          "fullDescription" : {
            "text" : "The method doExecCommand() in PingAction.java calls exec() with a command built from untrusted data. This call can cause the program to execute malicious commands on behalf of an attacker.\n\n\n"
          },
          "help" : {
            "text" : "Command injection vulnerabilities take two forms:\n\n- An attacker can change the command that the program executes: the attacker explicitly controls what the command is.\n\n- An attacker can change the environment in which the command executes: the attacker implicitly controls what the command means.\n\nIn this case, we are primarily concerned with the first scenario, the possibility that an attacker may be able to control the command that is executed. Command injection vulnerabilities of this type occur when:\n\n1. Data enters the application from an untrusted source.\n\nIn this case, the data enters at setAddress() in PingAction.java on line 18.\n\n\n2. The data is used as or as part of a string representing a command that is executed by the application.\n\nIn this case, the command is executed by exec() in PingAction.java on line 46.\n\n3. By executing the command, the application gives an attacker a privilege or capability that the attacker would not otherwise have.\n\nExample 1: The following code from a system utility uses the system property APPHOME to determine the directory in which it is installed and then executes an initialization script based on a relative path from the specified directory.\n\n\n\t...\n\tString home = System.getProperty(\"APPHOME\");\n\tString cmd = home + INITCMD;\n\tjava.lang.Runtime.getRuntime().exec(cmd);\n\t...\n\n\nThe code in Example 1 allows an attacker to execute arbitrary commands with the elevated privilege of the application by modifying the system property APPHOME to point to a different path containing a malicious version of INITCMD. Because the program does not validate the value read from the environment, if an attacker can control the value of the system property APPHOME, then they can fool the application into running malicious code and take control of the system.\n\nExample 2: The following code is from an administrative web application designed to allow users to kick off a backup of an Oracle database using a batch-file wrapper around the rman utility and then run a cleanup.bat script to delete some temporary files. The script rmanDB.bat accepts a single command line parameter, which specifies the type of backup to perform. Because access to the database is restricted, the application runs the backup as a privileged user.\n\n\n...\nString btype = request.getParameter(\"backuptype\");\nString cmd = new String(\"cmd.exe /K\n\\\"c:\\\\util\\\\rmanDB.bat \"+btype+\"&amp;&amp;c:\\\\util\\\\cleanup.bat\\\"\")\nSystem.Runtime.getRuntime().exec(cmd);\n...\n\n\nThe problem here is that the program does not do any validation on the backuptype parameter read from the user. Typically the Runtime.exec() function will not execute multiple commands, but in this case the program first runs the cmd.exe shell in order to run multiple commands with a single call to Runtime.exec(). After the shell is invoked, it will allow for the execution of multiple commands separated by two ampersands. If an attacker passes a string of the form \"&amp;&amp; del c:\\\\dbms\\\\*.*\", then the application will execute this command along with the others specified by the program. Because of the nature of the application, it runs with the privileges necessary to interact with the database, which means whatever command the attacker injects will run with those privileges as well.\n\nExample 3: The following code is from a web application that provides an interface through which users can update their password on the system. Part of the process for updating passwords in certain network environments is to run a make command in the /var/yp directory.\n\n\n...\nSystem.Runtime.getRuntime().exec(\"make\");\n...\n\n\nThe problem here is that the program does not specify an absolute path for make and fails to clean its environment prior to executing the call to Runtime.exec(). If an attacker can modify the $PATH variable to point to a malicious binary called make and cause the program to be executed in their environment, then the malicious binary will be loaded instead of the one intended. Because of the nature of the application, it runs with the privileges necessary to perform system operations, which means the attacker's make will now be run with these privileges, possibly giving the attacker complete control of the system.\n\nSome think that in the mobile world, classic vulnerabilities, such as command injection, do not make sense -- why would a user attack him or herself? However, keep in mind that the essence of mobile platforms is applications that are downloaded from various sources and run alongside each other on the same device. The likelihood of running a piece of malware next to a banking application is high, which necessitates expanding the attack surface of mobile applications to include inter-process communication.\n\nExample 4: The following code reads commands to be executed from an Android intent.\n\n\n...\n        String[] cmds = this.getIntent().getStringArrayExtra(\"commands\");\n        Process p = Runtime.getRuntime().exec(\"su\");\n        DataOutputStream os = new DataOutputStream(p.getOutputStream());\n        for (String cmd : cmds) {\n                os.writeBytes(cmd+\"\n\");\n        }\n        os.writeBytes(\"exit\n\");\n        os.flush();\n...\n\n\nOn a rooted device, a malicious application can force a victim application to execute arbitrary commands with super user privileges.\n\nDo not allow users to have direct control over the commands executed by the program. In cases where user input must affect the command to be run, use the input only to make a selection from a predetermined set of safe commands. If the input appears to be malicious, the value passed to the command execution function should either default to some safe selection from this set or the program should decline to execute any command at all.\n\nIn cases where user input must be used as an argument to a command executed by the program, this approach often becomes impractical because the set of legitimate argument values is too large or too hard to keep track of. Developers often fall back on implementing a deny list in these situations. A deny list is used to selectively reject or escape potentially dangerous characters before using the input. Any list of unsafe characters is likely to be incomplete and will be heavily dependent on the system where the commands are executed. A better approach is to create a list of characters that are permitted to appear in the input and accept input composed exclusively of characters in the approved set.\n\nAn attacker may indirectly control commands executed by a program by modifying the environment in which they are executed. The environment should not be trusted and precautions should be taken to prevent an attacker from using some manipulation of the environment to perform an attack. Whenever possible, commands should be controlled by the application and executed using an absolute path. In cases where the path is not known at compile time, such as for cross-platform applications, an absolute path should be constructed from trusted values during execution. Command values and paths read from configuration files or the environment should be sanity-checked against a set of invariants that define valid values.\n\nOther checks can sometimes be performed to detect if these sources may have been tampered with. For example, if a configuration file is world-writable, the program might refuse to run. In cases where information about the binary to be executed is known in advance, the program may perform checks to verify the identity of the binary. If a binary should always be owned by a particular user or have a particular set of access permissions assigned to it, these properties can be verified programmatically before the binary is executed.\n\nAlthough it may be impossible to completely protect a program from an imaginative attacker bent on controlling the commands the program executes, be sure to apply the principle of least privilege wherever the program executes an external command: do not hold privileges that are not essential to the execution of the command.\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4317/?engineType=SCA&issue=55CD8DAA81FEA1C3CC22A6AAFB970A94"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "4356",
          "shortDescription" : {
            "text" : "Denial of Service"
          },
          "fullDescription" : {
            "text" : "The call to readLine() at PingAction.java line 52 might allow an attacker to crash the program or otherwise make it unavailable to legitimate users.\n\n\n"
          },
          "help" : {
            "text" : "Attackers may be able to deny service to legitimate users by flooding the application with requests, but flooding attacks can often be defused at the network layer. More problematic are bugs that allow an attacker to overload the application using a small number of requests. Such bugs allow the attacker to specify the quantity of system resources their requests will consume or the duration for which they will use them.\n\nExample 1: The following code allows a user to specify the amount of time for which a thread will sleep. By specifying a large number, an attacker may tie up the thread indefinitely. With a small number of requests, the attacker may deplete the application's thread pool.\n\n\n  int usrSleepTime = Integer.parseInt(usrInput);\n  Thread.sleep(usrSleepTime);\n\n\nExample 2: The following code reads a String from a zip file. Because it uses the readLine() method, it will read an unbounded amount of input. An attacker may take advantage of this code to cause an OutOfMemoryException or to consume a large amount of memory so that the program spends more time performing garbage collection or runs out of memory during some subsequent operation.\n\n\n  InputStream zipInput = zipFile.getInputStream(zipEntry);\n  Reader zipReader = new InputStreamReader(zipInput);\n  BufferedReader br = new BufferedReader(zipReader);\n  String line = br.readLine();\n\n\nValidate user input to ensure that it will not cause inappropriate resource utilization.\n\nExample 3: The following code allows a user to specify the amount of time for which a thread will sleep just as in Example 1, but only if the value is within reasonable bounds.\n\n  int usrSleepTime = Integer.parseInt(usrInput);\n  if (usrSleepTime &gt;= SLEEP_MIN &amp;&amp;\n      usrSleepTime &lt;= SLEEP_MAX) {\n    Thread.sleep(usrSleepTime);\n  } else {\n    throw new Exception(\"Invalid sleep duration\");\n  }\n}\n\n\nExample 4: The following code reads a String from a zip file just as in Example 2, but the maximum string length it will read is MAX_STR_LEN characters.\n\n  InputStream zipInput = zipFile.getInputStream(zipEntry);\n  Reader zipReader = new InputStreamReader(zipInput);\n  BufferedReader br = new BufferedReader(zipReader);\n  StringBuffer sb = new StringBuffer();\n  int intC;\n  while ((intC = br.read()) != -1) {\n    char c = (char) intC;\n    if (c == '\n') {\n      break;\n    }\n    if (sb.length() &gt;= MAX_STR_LEN) {\n      throw new Exception(\"input too long\");\n    }\n    sb.append(c);\n  }\n  String line = sb.toString();\n\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4356/?engineType=SCA&issue=FCAA83F93F95ABC9CEE6CE1E4A5C943F"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4355",
          "shortDescription" : {
            "text" : "Denial of Service"
          },
          "fullDescription" : {
            "text" : "The call to readLine() at PingAction.java line 59 might allow an attacker to crash the program or otherwise make it unavailable to legitimate users.\n\n\n"
          },
          "help" : {
            "text" : "Attackers may be able to deny service to legitimate users by flooding the application with requests, but flooding attacks can often be defused at the network layer. More problematic are bugs that allow an attacker to overload the application using a small number of requests. Such bugs allow the attacker to specify the quantity of system resources their requests will consume or the duration for which they will use them.\n\nExample 1: The following code allows a user to specify the amount of time for which a thread will sleep. By specifying a large number, an attacker may tie up the thread indefinitely. With a small number of requests, the attacker may deplete the application's thread pool.\n\n\n  int usrSleepTime = Integer.parseInt(usrInput);\n  Thread.sleep(usrSleepTime);\n\n\nExample 2: The following code reads a String from a zip file. Because it uses the readLine() method, it will read an unbounded amount of input. An attacker may take advantage of this code to cause an OutOfMemoryException or to consume a large amount of memory so that the program spends more time performing garbage collection or runs out of memory during some subsequent operation.\n\n\n  InputStream zipInput = zipFile.getInputStream(zipEntry);\n  Reader zipReader = new InputStreamReader(zipInput);\n  BufferedReader br = new BufferedReader(zipReader);\n  String line = br.readLine();\n\n\nValidate user input to ensure that it will not cause inappropriate resource utilization.\n\nExample 3: The following code allows a user to specify the amount of time for which a thread will sleep just as in Example 1, but only if the value is within reasonable bounds.\n\n  int usrSleepTime = Integer.parseInt(usrInput);\n  if (usrSleepTime &gt;= SLEEP_MIN &amp;&amp;\n      usrSleepTime &lt;= SLEEP_MAX) {\n    Thread.sleep(usrSleepTime);\n  } else {\n    throw new Exception(\"Invalid sleep duration\");\n  }\n}\n\n\nExample 4: The following code reads a String from a zip file just as in Example 2, but the maximum string length it will read is MAX_STR_LEN characters.\n\n  InputStream zipInput = zipFile.getInputStream(zipEntry);\n  Reader zipReader = new InputStreamReader(zipInput);\n  BufferedReader br = new BufferedReader(zipReader);\n  StringBuffer sb = new StringBuffer();\n  int intC;\n  while ((intC = br.read()) != -1) {\n    char c = (char) intC;\n    if (c == '\n') {\n      break;\n    }\n    if (sb.length() &gt;= MAX_STR_LEN) {\n      throw new Exception(\"input too long\");\n    }\n    sb.append(c);\n  }\n  String line = sb.toString();\n\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4355/?engineType=SCA&issue=FCAA83F93F95ABC9CEE6CE1E4A5C943E"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4352",
          "shortDescription" : {
            "text" : "Struts 2: Unvalidated Action"
          },
          "fullDescription" : {
            "text" : "Struts2 Actions should utilize the Struts Validation framework to prevent vulnerabilities that result from unchecked input.\n\n\n"
          },
          "help" : {
            "text" : "Unchecked input is the leading cause of vulnerabilities in J2EE applications. Unchecked input can lead to numerous vulnerabilities, including cross-site scripting, process control, and SQL injection. Although J2EE applications are not generally susceptible to memory corruption attacks, if a J2EE application interfaces with native code that does not perform array bounds checking, an attacker may be able to use an input validation mistake in the J2EE application to launch a buffer overflow attack.\n\nTo prevent such attacks, use the Struts Validation framework to check all program input before it is processed by the application. Use Fortify Static Code Analyzer to ensure that there are no holes in your configuration of the Struts Validator.\n\nExample uses of the validator include checking to ensure that:\n\n- Phone number fields contain only valid characters in phone numbers\n\n- Boolean values are only \"T\" or \"F\"\n\n- Free-form strings are of a reasonable length and composition\n\nDefine a Struts Validator for the corresponding Action. An example of a typical \"ActionClass-validation.xml\" setup is:\n\n&lt;validators&gt;\n  &lt;field name=\"user.firstName\"&gt;\n    &lt;field-validator type=\"requiredstring\"&gt;\n      &lt;message key=\"user.firstName.empty\"/&gt;\n    &lt;/field-validator&gt;\n  &lt;/field&gt;\n...\n\nThe configuration file ActionClass-validation.xml contains the definitions of validation functions, called validators.\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4352/?engineType=SCA&issue=F37D902FE731E75BAC2552AB489CF0F9"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4300",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at ProductAction.java line 89 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get repetitive, but \"condensing\" catch blocks by catching a high-level class such as Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes such as Exception, Throwable, Error, or RuntimeException except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4300/?engineType=SCA&issue=0A55E71B873B79684AA6BC9750D4CEBB"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4301",
          "shortDescription" : {
            "text" : "Struts 2: Unvalidated Action"
          },
          "fullDescription" : {
            "text" : "Struts2 Actions should utilize the Struts Validation framework to prevent vulnerabilities that result from unchecked input.\n\n\n"
          },
          "help" : {
            "text" : "Unchecked input is the leading cause of vulnerabilities in J2EE applications. Unchecked input can lead to numerous vulnerabilities, including cross-site scripting, process control, and SQL injection. Although J2EE applications are not generally susceptible to memory corruption attacks, if a J2EE application interfaces with native code that does not perform array bounds checking, an attacker may be able to use an input validation mistake in the J2EE application to launch a buffer overflow attack.\n\nTo prevent such attacks, use the Struts Validation framework to check all program input before it is processed by the application. Use Fortify Static Code Analyzer to ensure that there are no holes in your configuration of the Struts Validator.\n\nExample uses of the validator include checking to ensure that:\n\n- Phone number fields contain only valid characters in phone numbers\n\n- Boolean values are only \"T\" or \"F\"\n\n- Free-form strings are of a reasonable length and composition\n\nDefine a Struts Validator for the corresponding Action. An example of a typical \"ActionClass-validation.xml\" setup is:\n\n&lt;validators&gt;\n  &lt;field name=\"user.firstName\"&gt;\n    &lt;field-validator type=\"requiredstring\"&gt;\n      &lt;message key=\"user.firstName.empty\"/&gt;\n    &lt;/field-validator&gt;\n  &lt;/field&gt;\n...\n\nThe configuration file ActionClass-validation.xml contains the definitions of validation functions, called validators.\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4301/?engineType=SCA&issue=17EC79C5744FAE22272C6D7198B47113"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4331",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at Register.java line 88 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get repetitive, but \"condensing\" catch blocks by catching a high-level class such as Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes such as Exception, Throwable, Error, or RuntimeException except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4331/?engineType=SCA&issue=96EC1700A732CDD6F8AC87E8F8B0F4A6"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4319",
          "shortDescription" : {
            "text" : "Struts 2: Unvalidated Action"
          },
          "fullDescription" : {
            "text" : "Struts2 Actions should utilize the Struts Validation framework to prevent vulnerabilities that result from unchecked input.\n\n\n"
          },
          "help" : {
            "text" : "Unchecked input is the leading cause of vulnerabilities in J2EE applications. Unchecked input can lead to numerous vulnerabilities, including cross-site scripting, process control, and SQL injection. Although J2EE applications are not generally susceptible to memory corruption attacks, if a J2EE application interfaces with native code that does not perform array bounds checking, an attacker may be able to use an input validation mistake in the J2EE application to launch a buffer overflow attack.\n\nTo prevent such attacks, use the Struts Validation framework to check all program input before it is processed by the application. Use Fortify Static Code Analyzer to ensure that there are no holes in your configuration of the Struts Validator.\n\nExample uses of the validator include checking to ensure that:\n\n- Phone number fields contain only valid characters in phone numbers\n\n- Boolean values are only \"T\" or \"F\"\n\n- Free-form strings are of a reasonable length and composition\n\nDefine a Struts Validator for the corresponding Action. An example of a typical \"ActionClass-validation.xml\" setup is:\n\n&lt;validators&gt;\n  &lt;field name=\"user.firstName\"&gt;\n    &lt;field-validator type=\"requiredstring\"&gt;\n      &lt;message key=\"user.firstName.empty\"/&gt;\n    &lt;/field-validator&gt;\n  &lt;/field&gt;\n...\n\nThe configuration file ActionClass-validation.xml contains the definitions of validation functions, called validators.\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4319/?engineType=SCA&issue=5E4DF2EF8C888F6DFA97C0B957F84BE5"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4322",
          "shortDescription" : {
            "text" : "Password Management: Password in Comment"
          },
          "fullDescription" : {
            "text" : "Storing passwords or password details in plain text anywhere in the system or system code may compromise system security in a way that cannot be easily remedied.\n\n\n"
          },
          "help" : {
            "text" : "It is never a good idea to hardcode a password. Storing password details within comments is equivalent to hardcoding passwords. Not only does it allow all of the project's developers to view the password, it also makes fixing the problem extremely difficult. After the code is in production, the password is now leaked to the outside world and cannot be protected or changed without patching the software. If the account protected by the password is compromised, the owners of the system must choose between security and availability.\n\nIn this case, the password details appear in the comment in ResetPassword.java on line 58.\n\n\nExample: The following comment specifies the default password to connect to a database:\n\n\n...\n// Default username for database connection is \"scott\"\n// Default password for database connection is \"tiger\"\n...\n\n\nThis code will run successfully, but anyone who has access to it will have access to the password. An employee with access to this information can use it to break into the system.\n\nPasswords should never be hardcoded and should generally be obfuscated and managed in an external source. Storing passwords in plain text anywhere on the system allows anyone with sufficient permissions to read and potentially misuse the password.\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4322/?engineType=SCA&issue=6A308A8B5B632A509739A8C79FEFC0F4"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4315",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at ResetPassword.java line 77 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get repetitive, but \"condensing\" catch blocks by catching a high-level class such as Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes such as Exception, Throwable, Error, or RuntimeException except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4315/?engineType=SCA&issue=54ED032CBF0EA1F83665A6E3B5616396"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4328",
          "shortDescription" : {
            "text" : "Struts 2: Unvalidated Action"
          },
          "fullDescription" : {
            "text" : "Struts2 Actions should utilize the Struts Validation framework to prevent vulnerabilities that result from unchecked input.\n\n\n"
          },
          "help" : {
            "text" : "Unchecked input is the leading cause of vulnerabilities in J2EE applications. Unchecked input can lead to numerous vulnerabilities, including cross-site scripting, process control, and SQL injection. Although J2EE applications are not generally susceptible to memory corruption attacks, if a J2EE application interfaces with native code that does not perform array bounds checking, an attacker may be able to use an input validation mistake in the J2EE application to launch a buffer overflow attack.\n\nTo prevent such attacks, use the Struts Validation framework to check all program input before it is processed by the application. Use Fortify Static Code Analyzer to ensure that there are no holes in your configuration of the Struts Validator.\n\nExample uses of the validator include checking to ensure that:\n\n- Phone number fields contain only valid characters in phone numbers\n\n- Boolean values are only \"T\" or \"F\"\n\n- Free-form strings are of a reasonable length and composition\n\nDefine a Struts Validator for the corresponding Action. An example of a typical \"ActionClass-validation.xml\" setup is:\n\n&lt;validators&gt;\n  &lt;field name=\"user.firstName\"&gt;\n    &lt;field-validator type=\"requiredstring\"&gt;\n      &lt;message key=\"user.firstName.empty\"/&gt;\n    &lt;/field-validator&gt;\n  &lt;/field&gt;\n...\n\nThe configuration file ActionClass-validation.xml contains the definitions of validation functions, called validators.\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4328/?engineType=SCA&issue=8CF9F9724D45A35960B497BE864D0EFF"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4351",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at UserAction.java line 115 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get repetitive, but \"condensing\" catch blocks by catching a high-level class such as Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes such as Exception, Throwable, Error, or RuntimeException except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4351/?engineType=SCA&issue=F0D4FBB4B58E8832C40505D573758718"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4354",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Throws"
          },
          "fullDescription" : {
            "text" : "The method intercept() in AuthenticationInterceptor.java throws a generic exception making it harder for callers to do a good job of error handling and recovery.\n\n\n"
          },
          "help" : {
            "text" : "Declaring a method to throw Exception or Throwable makes it difficult for callers to do good error handling and error recovery. Java's exception mechanism is set up to make it easy for callers to anticipate what can go wrong and write code to handle each specific exceptional circumstance. Declaring that a method throws a generic form of exception defeats this system.\n\nExample: The following method throws three types of exceptions.\n\n\npublic void doExchange()\n  throws IOException, InvocationTargetException,\n         SQLException {\n  ...\n}\n\n\n\nWhile it might seem tidier to write\n\n\npublic void doExchange()\n  throws Exception {\n  ...\n}\n\n\ndoing so hampers the caller's ability to understand and handle the exceptions that occur. Further, if a later revision of doExchange() introduces a new type of exception that should be treated differently than previous exceptions, there is no easy way to enforce this requirement.\n\nDo not declare methods to throw Exception or Throwable. If the exceptions thrown by a method are not recoverable or should not generally be caught by the caller, consider throwing unchecked exceptions rather than checked exceptions. This can be accomplished by implementing exception classes that extend RuntimeException or Error instead of Exception, or add a try/catch wrapper in your method to convert checked exceptions to unchecked exceptions.\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4354/?engineType=SCA&issue=F88D2FDE11E6BC2D97A2C5EADBEC645D"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4347",
          "shortDescription" : {
            "text" : "Dead Code: Unused Method"
          },
          "fullDescription" : {
            "text" : "The method setTimestamps() in Product.java is not reachable from any method outside the class. It is dead code. Dead code is defined as code that is never directly or indirectly executed by a public method.\n\n\n"
          },
          "help" : {
            "text" : "This method is never called or is only called from other dead code.\n\nExample 1: In the following class, the method doWork() can never be called.\n\n\npublic class Dead {\n  private void doWork() {\n    System.out.println(\"doing work\");\n  }\n  public static void main(String[] args) {\n    System.out.println(\"running Dead\");\n  }\n}\n\n\nExample 2: In the following class, two private methods call each other, but since neither one is ever invoked from anywhere else, they are both dead code.\n\n\npublic class DoubleDead {\n  private void doTweedledee() {\n    doTweedledumb();\n  }\n  private void doTweedledumb() {\n    doTweedledee();\n  }\n  public static void main(String[] args) {\n    System.out.println(\"running DoubleDead\");\n  }\n}\n\n\n(In this case it is a good thing that the methods are dead: invoking either one would cause an infinite loop.)\n\nA dead method may indicate a bug in dispatch code.\n\nExample 3: If method is flagged as dead named getWitch() in a class that also contains the following dispatch method, it may be because of a copy-and-paste error. The 'w' case should return getWitch() not getMummy().\n\n\npublic ScaryThing getScaryThing(char st) {\n  switch(st) {\n    case 'm':\n      return getMummy();\n    case 'w':\n      return getMummy();\n    default:\n      return getBlob();\n  }\n}\n\n\nIn general, you should repair or remove dead code. To repair dead code, execute the dead code directly or indirectly through a public method. Dead code causes additional complexity and maintenance burden without contributing to the functionality of the program.\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4347/?engineType=SCA&issue=CB467795FAB311085FA770F87C37DD67"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4359",
          "shortDescription" : {
            "text" : "Mass Assignment: Sensitive Field Exposure"
          },
          "fullDescription" : {
            "text" : "A sensitive field defined in User.java on line 21 is exposed to the model binder.\n\n\n"
          },
          "help" : {
            "text" : "Modern frameworks allow developers to automatically bind HTTP request parameters from both request query and body into model objects for ease of development and increased productivity. If the binder is not correctly configured to control which HTTP request parameters are bound to which model attributes, an attacker may be able to abuse the model binding process and set any other attributes that should not be exposed to user control. This binding is possible even if the model attributes do not appear in the web forms or API contracts.\n\nExample 1: The following Spring controller method (registerUser) is accessed from a web form that asks a user to register an account by providing their first name, last name, and age:\n\n\n@RequestMapping(method = RequestMethod.POST)\npublic String registerUser(@ModelAttribute(\"user\") User user, BindingResult result, SessionStatus status) {\n  if (db.save(user).hasErrors()) {\n    return \"CustomerForm\";\n  } else {\n    status.setComplete();\n    return \"CustomerSuccess\";\n  }\n}\n\n\nIf registration is successful, the user data will be persisted in the database. The User class is defined as:\n\n\npublic class User {\n  private String name;\n  private String lastname;\n  private int age;\n  private Details details;\n\n  // Public Getters and Setters\n  ...\n}\n\n\nAnd the Details class is defined as:\n\n\npublic class Details {\n  private boolean is_admin;\n  private int id;\n  private Date login_date;\n\n  // Public Getters and Setters\n  ...\n}\n\n\nGiven this scenario, an attacker may be able to explore the application and discover that there is a details attribute in the User model. If this is the case, the attacker may then attempt to overwrite the current values assigned to their attributes.\nIf an attacker can find out these internal attributes, and the framework binder is not correctly configured in order to disallow binding of these attributes, then the attacker would be able to register an administrator account by sending the following request:\n\n\nname=John&amp;lastname=Smith&amp;age=22&amp;details.is_admin=true\n\n\nIn order to avoid mass assignment vulnerabilities it is important to control the HTTP request to model class binding process. There are different alternatives depending on the framework used:\n\nArchitectural: Define dedicated DTO classes to be bound to user data and containing only those attributes that should be exposed to end users. Map their attributes with the Domain Objects used along the application. These Domain Objects will contain attributes to receive the validated user data and extra attributes that should never be exposed to user control.\n\nBinder configuration: Certain frameworks such as Spring, allow the developers to configure the model binder to accept or reject HTTP request parameters based on their names. For example:\n\nExample 2: \n\n\n@Override\nprotected void initBinder(HttpServletRequest request, ServletRequestDataBinder binder) throws Exception {\n    binder.setDisallowedFields(new String[]{\"details.role\", \"details.age\", \"is_admin\"});\n}\n\n\nModel class configuration: Depending on the frameworks used and the serialization/deserialization libraries in use, the model classes to be bound to the HTTP request parameters can be annotated to allow, or disallow, certain attribute bindings. For example, if user data is sent in JSON format and Jackson library is used to deserialize this data, the @JsonIgnore annotation can be used to tell Jackson to ignore a given attribute for serialization and deserialization purposes.\n\nExample 3: \n\n\npublic class User {\n\n    @JsonIgnore\n    private String role;\n    private String name;\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public String getRole() {\n        return role;\n    }\n    public void setRole(String role) {\n        this.role = role;\n    }\n\n\nIn other frameworks such as Apache Struts 1 and 2, the framework will only allow binding HTTP request parameters to class members with public setters. In case a given attribute should not be exposed, the setter should be declared private.\n\nExample 4: \n\n\nprivate String role;\nprivate void setRole(String role)  {\n   this.role = role;\n}\n\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4359/?engineType=SCA&issue=FEF2859639B1D1F00213E4DF1C9257EF"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "4349",
          "shortDescription" : {
            "text" : "Dead Code: Unused Field"
          },
          "fullDescription" : {
            "text" : "The field createdAt is never used.\n\n\n"
          },
          "help" : {
            "text" : "This field is never accessed, except perhaps by dead code. Dead code is defined as code that is never directly or indirectly executed by a public method. It is likely that the field is simply vestigial, but it is also possible that the unused field points out a bug.\n\nExample 1: The field named glue is not used in the following class. The author of the class has accidentally put quotes around the field name, transforming it into a string constant.\n\n\npublic class Dead {\n\n  String glue;\n\n  public String getGlue() {\n    return \"glue\";\n  }\n\n}\n\n\nExample 2: The field named glue is used in the following class, but only from a method that is never called.\n\n\npublic class Dead {\n\n  String glue;\n\n  private String getGlue() {\n    return glue;\n  }\n\n}\n\n\nIn general, you should repair or remove dead code. To repair dead code, execute the dead code directly or indirectly through a public method. Dead code causes additional complexity and maintenance burden without contributing to the functionality of the program.\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4349/?engineType=SCA&issue=D8BD2E8C095E7052BBFB2ECAEA37231C"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4312",
          "shortDescription" : {
            "text" : "Dead Code: Unused Field"
          },
          "fullDescription" : {
            "text" : "The field updatedAt is never used.\n\n\n"
          },
          "help" : {
            "text" : "This field is never accessed, except perhaps by dead code. Dead code is defined as code that is never directly or indirectly executed by a public method. It is likely that the field is simply vestigial, but it is also possible that the unused field points out a bug.\n\nExample 1: The field named glue is not used in the following class. The author of the class has accidentally put quotes around the field name, transforming it into a string constant.\n\n\npublic class Dead {\n\n  String glue;\n\n  public String getGlue() {\n    return \"glue\";\n  }\n\n}\n\n\nExample 2: The field named glue is used in the following class, but only from a method that is never called.\n\n\npublic class Dead {\n\n  String glue;\n\n  private String getGlue() {\n    return glue;\n  }\n\n}\n\n\nIn general, you should repair or remove dead code. To repair dead code, execute the dead code directly or indirectly through a public method. Dead code causes additional complexity and maintenance burden without contributing to the functionality of the program.\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4312/?engineType=SCA&issue=46D0FAF0138E403208D7FCFB3919D41B"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4345",
          "shortDescription" : {
            "text" : "Dead Code: Unused Method"
          },
          "fullDescription" : {
            "text" : "The method setTimestamps() in User.java is not reachable from any method outside the class. It is dead code. Dead code is defined as code that is never directly or indirectly executed by a public method.\n\n\n"
          },
          "help" : {
            "text" : "This method is never called or is only called from other dead code.\n\nExample 1: In the following class, the method doWork() can never be called.\n\n\npublic class Dead {\n  private void doWork() {\n    System.out.println(\"doing work\");\n  }\n  public static void main(String[] args) {\n    System.out.println(\"running Dead\");\n  }\n}\n\n\nExample 2: In the following class, two private methods call each other, but since neither one is ever invoked from anywhere else, they are both dead code.\n\n\npublic class DoubleDead {\n  private void doTweedledee() {\n    doTweedledumb();\n  }\n  private void doTweedledumb() {\n    doTweedledee();\n  }\n  public static void main(String[] args) {\n    System.out.println(\"running DoubleDead\");\n  }\n}\n\n\n(In this case it is a good thing that the methods are dead: invoking either one would cause an infinite loop.)\n\nA dead method may indicate a bug in dispatch code.\n\nExample 3: If method is flagged as dead named getWitch() in a class that also contains the following dispatch method, it may be because of a copy-and-paste error. The 'w' case should return getWitch() not getMummy().\n\n\npublic ScaryThing getScaryThing(char st) {\n  switch(st) {\n    case 'm':\n      return getMummy();\n    case 'w':\n      return getMummy();\n    default:\n      return getBlob();\n  }\n}\n\n\nIn general, you should repair or remove dead code. To repair dead code, execute the dead code directly or indirectly through a public method. Dead code causes additional complexity and maintenance burden without contributing to the functionality of the program.\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4345/?engineType=SCA&issue=C47DE0274E2DF9B3CB5771203FE5BA90"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4357",
          "shortDescription" : {
            "text" : "Struts 2: Unvalidated Action"
          },
          "fullDescription" : {
            "text" : "Struts2 Actions should utilize the Struts Validation framework to prevent vulnerabilities that result from unchecked input.\n\n\n"
          },
          "help" : {
            "text" : "Unchecked input is the leading cause of vulnerabilities in J2EE applications. Unchecked input can lead to numerous vulnerabilities, including cross-site scripting, process control, and SQL injection. Although J2EE applications are not generally susceptible to memory corruption attacks, if a J2EE application interfaces with native code that does not perform array bounds checking, an attacker may be able to use an input validation mistake in the J2EE application to launch a buffer overflow attack.\n\nTo prevent such attacks, use the Struts Validation framework to check all program input before it is processed by the application. Use Fortify Static Code Analyzer to ensure that there are no holes in your configuration of the Struts Validator.\n\nExample uses of the validator include checking to ensure that:\n\n- Phone number fields contain only valid characters in phone numbers\n\n- Boolean values are only \"T\" or \"F\"\n\n- Free-form strings are of a reasonable length and composition\n\nDefine a Struts Validator for the corresponding Action. An example of a typical \"ActionClass-validation.xml\" setup is:\n\n&lt;validators&gt;\n  &lt;field name=\"user.firstName\"&gt;\n    &lt;field-validator type=\"requiredstring\"&gt;\n      &lt;message key=\"user.firstName.empty\"/&gt;\n    &lt;/field-validator&gt;\n  &lt;/field&gt;\n...\n\nThe configuration file ActionClass-validation.xml contains the definitions of validation functions, called validators.\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4357/?engineType=SCA&issue=FD10023E2A00EAC1C7E48500D18B16D6"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4304",
          "shortDescription" : {
            "text" : "Struts 2: Unvalidated Action"
          },
          "fullDescription" : {
            "text" : "Struts2 Actions should utilize the Struts Validation framework to prevent vulnerabilities that result from unchecked input.\n\n\n"
          },
          "help" : {
            "text" : "Unchecked input is the leading cause of vulnerabilities in J2EE applications. Unchecked input can lead to numerous vulnerabilities, including cross-site scripting, process control, and SQL injection. Although J2EE applications are not generally susceptible to memory corruption attacks, if a J2EE application interfaces with native code that does not perform array bounds checking, an attacker may be able to use an input validation mistake in the J2EE application to launch a buffer overflow attack.\n\nTo prevent such attacks, use the Struts Validation framework to check all program input before it is processed by the application. Use Fortify Static Code Analyzer to ensure that there are no holes in your configuration of the Struts Validator.\n\nExample uses of the validator include checking to ensure that:\n\n- Phone number fields contain only valid characters in phone numbers\n\n- Boolean values are only \"T\" or \"F\"\n\n- Free-form strings are of a reasonable length and composition\n\nDefine a Struts Validator for the corresponding Action. An example of a typical \"ActionClass-validation.xml\" setup is:\n\n&lt;validators&gt;\n  &lt;field name=\"user.firstName\"&gt;\n    &lt;field-validator type=\"requiredstring\"&gt;\n      &lt;message key=\"user.firstName.empty\"/&gt;\n    &lt;/field-validator&gt;\n  &lt;/field&gt;\n...\n\nThe configuration file ActionClass-validation.xml contains the definitions of validation functions, called validators.\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4304/?engineType=SCA&issue=1E77E17D1C67D05A6C5401C0E8E88F08"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4348",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Throws"
          },
          "fullDescription" : {
            "text" : "The method execute() in HelloWorld.java throws a generic exception making it harder for callers to do a good job of error handling and recovery.\n\n\n"
          },
          "help" : {
            "text" : "Declaring a method to throw Exception or Throwable makes it difficult for callers to do good error handling and error recovery. Java's exception mechanism is set up to make it easy for callers to anticipate what can go wrong and write code to handle each specific exceptional circumstance. Declaring that a method throws a generic form of exception defeats this system.\n\nExample: The following method throws three types of exceptions.\n\n\npublic void doExchange()\n  throws IOException, InvocationTargetException,\n         SQLException {\n  ...\n}\n\n\n\nWhile it might seem tidier to write\n\n\npublic void doExchange()\n  throws Exception {\n  ...\n}\n\n\ndoing so hampers the caller's ability to understand and handle the exceptions that occur. Further, if a later revision of doExchange() introduces a new type of exception that should be treated differently than previous exceptions, there is no easy way to enforce this requirement.\n\nDo not declare methods to throw Exception or Throwable. If the exceptions thrown by a method are not recoverable or should not generally be caught by the caller, consider throwing unchecked exceptions rather than checked exceptions. This can be accomplished by implementing exception classes that extend RuntimeException or Error instead of Exception, or add a try/catch wrapper in your method to convert checked exceptions to unchecked exceptions.\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4348/?engineType=SCA&issue=D2000A8F6E5E4CB3478CEB658026ABE5"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4342",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Throws"
          },
          "fullDescription" : {
            "text" : "The method execute() in Login.java throws a generic exception making it harder for callers to do a good job of error handling and recovery.\n\n\n"
          },
          "help" : {
            "text" : "Declaring a method to throw Exception or Throwable makes it difficult for callers to do good error handling and error recovery. Java's exception mechanism is set up to make it easy for callers to anticipate what can go wrong and write code to handle each specific exceptional circumstance. Declaring that a method throws a generic form of exception defeats this system.\n\nExample: The following method throws three types of exceptions.\n\n\npublic void doExchange()\n  throws IOException, InvocationTargetException,\n         SQLException {\n  ...\n}\n\n\n\nWhile it might seem tidier to write\n\n\npublic void doExchange()\n  throws Exception {\n  ...\n}\n\n\ndoing so hampers the caller's ability to understand and handle the exceptions that occur. Further, if a later revision of doExchange() introduces a new type of exception that should be treated differently than previous exceptions, there is no easy way to enforce this requirement.\n\nDo not declare methods to throw Exception or Throwable. If the exceptions thrown by a method are not recoverable or should not generally be caught by the caller, consider throwing unchecked exceptions rather than checked exceptions. This can be accomplished by implementing exception classes that extend RuntimeException or Error instead of Exception, or add a try/catch wrapper in your method to convert checked exceptions to unchecked exceptions.\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4342/?engineType=SCA&issue=BB4890248C7A4E106498D2003F3C55AD"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4332",
          "shortDescription" : {
            "text" : "Struts 2: Validator Without Action Field"
          },
          "fullDescription" : {
            "text" : "A Struts2 validator is defined for an action field that does not exist.\n\n\n"
          },
          "help" : {
            "text" : "A Struts2 validator definition refers to an action field that does not exist.\n\nIt is easy for developers to forget to update validation logic when they remove or rename action form mappings. One indication that validation logic is not being properly maintained is the presence of an orphaned validator definition.\n\nExamine the action validation file and search for possible matches for the orphaned validation definition. This result may indicate that an Action field has been renamed without the corresponding validation being updated.\n\nLook for other, perhaps more subtle, problems with the validation logic.\n\n- If the validation definition was previously used by an action form mapping that has\nsince been deleted, delete the unused validation form.\n\n- If the action form mapping has been renamed, consider renaming the validation\nfile so that the two are once again linked.\n\n- If the functionality present in the old action form mapping has been merged into\nanother action form mapping, check the unused validation logic against the new\nvalidation logic for consistency.\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4332/?engineType=SCA&issue=A038C3DA104795C1A4CF74955E157ABC"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4302",
          "shortDescription" : {
            "text" : "Password Management: Password in Configuration File"
          },
          "fullDescription" : {
            "text" : "Storing a plain text password in a configuration file may result in a system compromise.\n\n\n"
          },
          "help" : {
            "text" : "Storing a plain text password in a configuration file allows anyone who can read the file access to the password-protected resource. Developers sometimes believe that they cannot defend the application from someone who has access to the configuration, but this attitude makes an attacker's job easier. Good password management guidelines require that a password never be stored in plain text.\n\n\nIn this case, a hardcoded password exists in package.properties on line 3.\n\n\nA password should never be stored in plain text. An administrator should be required to enter the password when the system starts. If that approach is impractical, a less secure but often adequate solution is to obfuscate the password and scatter the de-obfuscation material around the system so that an attacker has to obtain and correctly combine multiple system resources to decipher the password.\n\nSome third-party products claim the ability to manage passwords in a more secure way. For example, WebSphere Application Server 4.x uses a simple XOR encryption algorithm for obfuscating values, but be skeptical about such facilities. WebSphere and other application servers offer outdated and relatively weak encryption mechanisms that are insufficient for security-sensitive environments. For a secure solution the only viable option is a proprietary one.\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4302/?engineType=SCA&issue=1B1FDA4A6A9C933BD42E3A4411FB544F"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "4299",
          "shortDescription" : {
            "text" : "OGNL Expression Injection: Struts 2"
          },
          "fullDescription" : {
            "text" : "Using wildcards (*) in Struts 2 action names enables evaluation of action names as OGNL expressions effectively enabling an attacker to modify system variables such as <code>Session</code> or execute arbitrary commands on the server.\n\n\n"
          },
          "help" : {
            "text" : "Object-Graph Navigation Language (OGNL) is an open-source Expression Language (EL) for Java that enables the evaluation of EL expressions in the Struts 2 Value Stack context. Enabling evaluation of unvalidated expressions against the Value Stack can give an attacker access to modify system variables or execute arbitrary code.\n\nStruts 2 allows definition of action mapping based on wildcards, for example:\n\n    &lt;action name=\"*\" class=\"com.acme.actions.example\"&gt;\n        &lt;result&gt;/example/{1}.jsp&lt;/result&gt;\n    &lt;/action&gt;\n\nIf a request doesn't match any other defined action, it will be matched by * and requested action name will be used to load JSP file based on the name of action.\nStruts 2 evaluates the wildcard replacements ({n} where n refers to the order of the wildcards in the action name) as OGNL expressions, and so it allows an attacker to submit any arbitrary OGNL expression to be evaluated.\n\nIt is strongly recommended to upgrade to Struts 2.3.14.3 that enables an action name allow list, allowing only the following characters:\n\n    [a-z]*[A-Z]*[0-9]*[.\\-_!/]*\n\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4299/?engineType=SCA&issue=01B2AC68E4FADD79102D89E1C5782205"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "4341",
          "shortDescription" : {
            "text" : "OGNL Expression Injection: Struts 2"
          },
          "fullDescription" : {
            "text" : "Application is deployed in Development Mode (devMode) allowing arbitrary command execution on the server and leaking detailed information about how the application is coded.\n\n\n"
          },
          "help" : {
            "text" : "Struts 2 has a setting called devMode (development mode). When this setting is enabled, Struts 2 will provide additional logging and debug information, which can significantly speed up development at the cost of a high impact in performance and security. devMode will raise the level of debug or normally ignorable problems to exceptions that would not normally be thrown in normal mode.\n\ndevMode also enable some debugging capabilities that allow developers to check variables stored in the Value Stack. These features can be triggered using the debug request parameter:\n- debug=console will pop up an OGNL evaluation console allowing developers to evaluate any arbitrary OGNL expression on the server.\n- debug=command will allow the developers to submit arbitrary OGNL expressions to be evaluated using the request parameter expression.\n- debug=xml will dump the parameters, context, session, and value stack as an XML document.\n- debug=browser will dump the parameters, context, session, and value stack in a browseable HTML document.\n\ndevMode is disabled by default and should never be enabled in production environments as it allows attackers to collect too many information about your application and execute arbitrary commands on the server. To make sure devMode is not enabled, verify that the constant struts.devMode is not set to true in any of the following configurations files:\n\nIn struts.xml configuration file or included documents:\n\n    &lt;constant name=\"struts.devMode\" value=\"true\" /&gt;\n\n\nIn struts.properties:\n\n    struts.devMode = true\n\n\nIn web.xml:\n\n    &lt;filter&gt;\n        &lt;filter-name&gt;struts2&lt;/filter-name&gt;\n        &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;\n        &lt;init-param&gt;\n            &lt;param-name&gt;struts.devMode&lt;/param-name&gt;\n            &lt;param-value&gt;true&lt;/param-value&gt;\n        &lt;/init-param&gt;\n    &lt;/filter&gt;\n\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4341/?engineType=SCA&issue=BADBE2462CA5AC27347FED8D19C63693"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "4324",
          "shortDescription" : {
            "text" : "Password Management: Password in Configuration File"
          },
          "fullDescription" : {
            "text" : "Storing a plain text password in a configuration file may result in a system compromise.\n\n\n"
          },
          "help" : {
            "text" : "Storing a plain text password in a configuration file allows anyone who can read the file access to the password-protected resource. Developers sometimes believe that they cannot defend the application from someone who has access to the configuration, but this attitude makes an attacker's job easier. Good password management guidelines require that a password never be stored in plain text.\n\n\nIn this case, a hardcoded password exists in config.properties on line 4.\n\n\nA password should never be stored in plain text. An administrator should be required to enter the password when the system starts. If that approach is impractical, a less secure but often adequate solution is to obfuscate the password and scatter the de-obfuscation material around the system so that an attacker has to obtain and correctly combine multiple system resources to decipher the password.\n\nSome third-party products claim the ability to manage passwords in a more secure way. For example, WebSphere Application Server 4.x uses a simple XOR encryption algorithm for obfuscating values, but be skeptical about such facilities. WebSphere and other application servers offer outdated and relatively weak encryption mechanisms that are insufficient for security-sensitive environments. For a secure solution the only viable option is a proprietary one.\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4324/?engineType=SCA&issue=7852C9684E0399E2AAA93461DD83E714"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "4305",
          "shortDescription" : {
            "text" : "Cross-Site Request Forgery"
          },
          "fullDescription" : {
            "text" : "The form post at Login.jsp line 24 must contain a user-specific secret in order to prevent an attacker from making unauthorized requests.\n\n\n"
          },
          "help" : {
            "text" : "A cross-site request forgery (CSRF) vulnerability occurs when:\n1. A Web application uses session cookies.\n\n2. The application acts on an HTTP request without verifying that the request was made with the user's consent.\n\n\nIn this case, the application generates HTTP request via a form post at Login.jsp line 24.\n\n\nA nonce is a cryptographic random value that is sent with a message to prevent replay attacks. If the request does not contain a nonce that proves its provenance, the code that handles the request is vulnerable to a CSRF attack (unless it does not change the state of the application). This means a Web application that uses session cookies has to take special precautions in order to ensure that an attacker can't trick users into submitting bogus requests. Imagine a Web application that allows administrators to create new accounts by submitting this form:\n\n\n&lt;form method=\"POST\" action=\"/new_user\" &gt;\n  Name of new user: &lt;input type=\"text\" name=\"username\"&gt;\n  Password for new user: &lt;input type=\"password\" name=\"user_passwd\"&gt;\n    &lt;input type=\"submit\" name=\"action\" value=\"Create User\"&gt;\n&lt;/form&gt;\n\n\nAn attacker might set up a Web site with the following:\n\n\n&lt;form method=\"POST\" action=\"http://www.example.com/new_user\"&gt;\n  &lt;input type=\"hidden\" name=\"username\" value=\"hacker\"&gt;\n  &lt;input type=\"hidden\" name=\"user_passwd\" value=\"hacked\"&gt;\n&lt;/form&gt;\n&lt;script&gt;\n  document.usr_form.submit();\n&lt;/script&gt;\n\n\nIf an administrator for example.com visits the malicious page while she has an active session on the site, she will unwittingly create an account for the attacker. This is a CSRF attack. It is possible because the application does not have a way to determine the provenance of the request. Any request could be a legitimate action chosen by the user or a faked action set up by an attacker. The attacker does not get to see the Web page that the bogus request generates, so the attack technique is only useful for requests that alter the state of the application.\n\nApplications that pass the session identifier in the URL rather than as a cookie do not have CSRF problems because there is no way for the attacker to access the session identifier and include it as part of the bogus request.\n\nCSRF is entry number five on the 2007 OWASP Top 10 list.\n\nApplications that use session cookies must include some piece of information in every form post that the back-end code can use to validate the provenance of the request. One way to do that is to include a random request identifier or nonce, as follows:\n\n\n  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, \"/new_user\");\n  body = addToPost(body, new_username);\n  body = addToPost(body, new_passwd);\n  body = addToPost(body, request_id);\n  rb.sendRequest(body, new NewAccountCallback(callback));\n\n\nThen the back-end logic can validate the request identifier before processing the rest of the form data. When possible, the request identifier should be unique to each server request rather than shared across every request for a particular session. As with session identifiers, the harder it is for an attacker to guess the request identifier, the harder it is to conduct a successful CSRF attack. The token should not be easily guessed and it should be protected in the same way that session tokens are protected, such as using SSLv3.\n\nAdditional mitigation techniques include:\n\nFramework protection: Most modern web application frameworks embed CSRF protection and they will automatically include and verify CSRF tokens.\nUse a Challenge-Response control: Forcing the customer to respond to a challenge sent by the server is a strong defense against CSRF. Some of the challenges that can be used for this purpose are: CAPTCHAs, password re-authentication and one-time tokens.\nCheck HTTP Referer/Origin headers: An attacker won't be able to spoof these headers while performing a CSRF attack. This makes these headers a useful method to prevent CSRF attacks.\nDouble-submit Session Cookie: Sending the session ID Cookie as a hidden form value in addition to the actual session ID Cookie is a good protection against CSRF attacks. The server will check both values and make sure they are identical before processing the rest of the form data. If an attacker submits a form in behalf of a user, he won't be able to modify the session ID cookie value as per the same-origin-policy.\nLimit Session Lifetime: When accessing protected resources using a CSRF attack, the attack will only be valid as long as the session ID sent as part of the attack is still valid on the server. Limiting the Session lifetime will reduce the probability of a successful attack.\n\nThe techniques described here can be defeated with XSS attacks. Effective CSRF mitigation includes XSS mitigation techniques.\n\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4305/?engineType=SCA&issue=1FCC1E56FEB6B3696535A573237EC792"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4309",
          "shortDescription" : {
            "text" : "Cross-Site Request Forgery"
          },
          "fullDescription" : {
            "text" : "The form post at Ping.jsp line 20 must contain a user-specific secret in order to prevent an attacker from making unauthorized requests.\n\n\n"
          },
          "help" : {
            "text" : "A cross-site request forgery (CSRF) vulnerability occurs when:\n1. A Web application uses session cookies.\n\n2. The application acts on an HTTP request without verifying that the request was made with the user's consent.\n\n\nIn this case, the application generates HTTP request via a form post at Ping.jsp line 20.\n\n\nA nonce is a cryptographic random value that is sent with a message to prevent replay attacks. If the request does not contain a nonce that proves its provenance, the code that handles the request is vulnerable to a CSRF attack (unless it does not change the state of the application). This means a Web application that uses session cookies has to take special precautions in order to ensure that an attacker can't trick users into submitting bogus requests. Imagine a Web application that allows administrators to create new accounts by submitting this form:\n\n\n&lt;form method=\"POST\" action=\"/new_user\" &gt;\n  Name of new user: &lt;input type=\"text\" name=\"username\"&gt;\n  Password for new user: &lt;input type=\"password\" name=\"user_passwd\"&gt;\n    &lt;input type=\"submit\" name=\"action\" value=\"Create User\"&gt;\n&lt;/form&gt;\n\n\nAn attacker might set up a Web site with the following:\n\n\n&lt;form method=\"POST\" action=\"http://www.example.com/new_user\"&gt;\n  &lt;input type=\"hidden\" name=\"username\" value=\"hacker\"&gt;\n  &lt;input type=\"hidden\" name=\"user_passwd\" value=\"hacked\"&gt;\n&lt;/form&gt;\n&lt;script&gt;\n  document.usr_form.submit();\n&lt;/script&gt;\n\n\nIf an administrator for example.com visits the malicious page while she has an active session on the site, she will unwittingly create an account for the attacker. This is a CSRF attack. It is possible because the application does not have a way to determine the provenance of the request. Any request could be a legitimate action chosen by the user or a faked action set up by an attacker. The attacker does not get to see the Web page that the bogus request generates, so the attack technique is only useful for requests that alter the state of the application.\n\nApplications that pass the session identifier in the URL rather than as a cookie do not have CSRF problems because there is no way for the attacker to access the session identifier and include it as part of the bogus request.\n\nCSRF is entry number five on the 2007 OWASP Top 10 list.\n\nApplications that use session cookies must include some piece of information in every form post that the back-end code can use to validate the provenance of the request. One way to do that is to include a random request identifier or nonce, as follows:\n\n\n  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, \"/new_user\");\n  body = addToPost(body, new_username);\n  body = addToPost(body, new_passwd);\n  body = addToPost(body, request_id);\n  rb.sendRequest(body, new NewAccountCallback(callback));\n\n\nThen the back-end logic can validate the request identifier before processing the rest of the form data. When possible, the request identifier should be unique to each server request rather than shared across every request for a particular session. As with session identifiers, the harder it is for an attacker to guess the request identifier, the harder it is to conduct a successful CSRF attack. The token should not be easily guessed and it should be protected in the same way that session tokens are protected, such as using SSLv3.\n\nAdditional mitigation techniques include:\n\nFramework protection: Most modern web application frameworks embed CSRF protection and they will automatically include and verify CSRF tokens.\nUse a Challenge-Response control: Forcing the customer to respond to a challenge sent by the server is a strong defense against CSRF. Some of the challenges that can be used for this purpose are: CAPTCHAs, password re-authentication and one-time tokens.\nCheck HTTP Referer/Origin headers: An attacker won't be able to spoof these headers while performing a CSRF attack. This makes these headers a useful method to prevent CSRF attacks.\nDouble-submit Session Cookie: Sending the session ID Cookie as a hidden form value in addition to the actual session ID Cookie is a good protection against CSRF attacks. The server will check both values and make sure they are identical before processing the rest of the form data. If an attacker submits a form in behalf of a user, he won't be able to modify the session ID cookie value as per the same-origin-policy.\nLimit Session Lifetime: When accessing protected resources using a CSRF attack, the attack will only be valid as long as the session ID sent as part of the attack is still valid on the server. Limiting the Session lifetime will reduce the probability of a successful attack.\n\nThe techniques described here can be defeated with XSS attacks. Effective CSRF mitigation includes XSS mitigation techniques.\n\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4309/?engineType=SCA&issue=390B3F841FB1997D52262A8F6003E92F"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4314",
          "shortDescription" : {
            "text" : "Cross-Site Request Forgery"
          },
          "fullDescription" : {
            "text" : "The form post at ProductEdit.jsp line 24 must contain a user-specific secret in order to prevent an attacker from making unauthorized requests.\n\n\n"
          },
          "help" : {
            "text" : "A cross-site request forgery (CSRF) vulnerability occurs when:\n1. A Web application uses session cookies.\n\n2. The application acts on an HTTP request without verifying that the request was made with the user's consent.\n\n\nIn this case, the application generates HTTP request via a form post at ProductEdit.jsp line 24.\n\n\nA nonce is a cryptographic random value that is sent with a message to prevent replay attacks. If the request does not contain a nonce that proves its provenance, the code that handles the request is vulnerable to a CSRF attack (unless it does not change the state of the application). This means a Web application that uses session cookies has to take special precautions in order to ensure that an attacker can't trick users into submitting bogus requests. Imagine a Web application that allows administrators to create new accounts by submitting this form:\n\n\n&lt;form method=\"POST\" action=\"/new_user\" &gt;\n  Name of new user: &lt;input type=\"text\" name=\"username\"&gt;\n  Password for new user: &lt;input type=\"password\" name=\"user_passwd\"&gt;\n    &lt;input type=\"submit\" name=\"action\" value=\"Create User\"&gt;\n&lt;/form&gt;\n\n\nAn attacker might set up a Web site with the following:\n\n\n&lt;form method=\"POST\" action=\"http://www.example.com/new_user\"&gt;\n  &lt;input type=\"hidden\" name=\"username\" value=\"hacker\"&gt;\n  &lt;input type=\"hidden\" name=\"user_passwd\" value=\"hacked\"&gt;\n&lt;/form&gt;\n&lt;script&gt;\n  document.usr_form.submit();\n&lt;/script&gt;\n\n\nIf an administrator for example.com visits the malicious page while she has an active session on the site, she will unwittingly create an account for the attacker. This is a CSRF attack. It is possible because the application does not have a way to determine the provenance of the request. Any request could be a legitimate action chosen by the user or a faked action set up by an attacker. The attacker does not get to see the Web page that the bogus request generates, so the attack technique is only useful for requests that alter the state of the application.\n\nApplications that pass the session identifier in the URL rather than as a cookie do not have CSRF problems because there is no way for the attacker to access the session identifier and include it as part of the bogus request.\n\nCSRF is entry number five on the 2007 OWASP Top 10 list.\n\nApplications that use session cookies must include some piece of information in every form post that the back-end code can use to validate the provenance of the request. One way to do that is to include a random request identifier or nonce, as follows:\n\n\n  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, \"/new_user\");\n  body = addToPost(body, new_username);\n  body = addToPost(body, new_passwd);\n  body = addToPost(body, request_id);\n  rb.sendRequest(body, new NewAccountCallback(callback));\n\n\nThen the back-end logic can validate the request identifier before processing the rest of the form data. When possible, the request identifier should be unique to each server request rather than shared across every request for a particular session. As with session identifiers, the harder it is for an attacker to guess the request identifier, the harder it is to conduct a successful CSRF attack. The token should not be easily guessed and it should be protected in the same way that session tokens are protected, such as using SSLv3.\n\nAdditional mitigation techniques include:\n\nFramework protection: Most modern web application frameworks embed CSRF protection and they will automatically include and verify CSRF tokens.\nUse a Challenge-Response control: Forcing the customer to respond to a challenge sent by the server is a strong defense against CSRF. Some of the challenges that can be used for this purpose are: CAPTCHAs, password re-authentication and one-time tokens.\nCheck HTTP Referer/Origin headers: An attacker won't be able to spoof these headers while performing a CSRF attack. This makes these headers a useful method to prevent CSRF attacks.\nDouble-submit Session Cookie: Sending the session ID Cookie as a hidden form value in addition to the actual session ID Cookie is a good protection against CSRF attacks. The server will check both values and make sure they are identical before processing the rest of the form data. If an attacker submits a form in behalf of a user, he won't be able to modify the session ID cookie value as per the same-origin-policy.\nLimit Session Lifetime: When accessing protected resources using a CSRF attack, the attack will only be valid as long as the session ID sent as part of the attack is still valid on the server. Limiting the Session lifetime will reduce the probability of a successful attack.\n\nThe techniques described here can be defeated with XSS attacks. Effective CSRF mitigation includes XSS mitigation techniques.\n\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4314/?engineType=SCA&issue=48146F4AA788200C848FDF8398B6C1D0"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4335",
          "shortDescription" : {
            "text" : "Hidden Field"
          },
          "fullDescription" : {
            "text" : "A hidden form field is used in ProductEdit.jsp on line 26.\n\n\n"
          },
          "help" : {
            "text" : "Programmers often trust the contents of hidden fields, expecting that users will not be able to view them or manipulate their contents. Attackers will violate these assumptions. They will examine the values written to hidden fields and alter them or replace the contents with attack data.\n\nExample: An &lt;input&gt; tag of type hidden indicates the use of a hidden field.\n\n&lt;input type=\"hidden\"&gt;\n\n\nIf hidden fields carry sensitive information, this information will be cached the same way the rest of the page is cached. This can lead to sensitive information being tucked away in the browser cache without the user's knowledge.\n\nExpect that attackers will study and decode all uses of hidden fields in the application. Treat hidden fields as untrusted input. Don't store information in hidden fields if the information should not be cached along with the rest of the page.\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4335/?engineType=SCA&issue=A4F905DAC1673BD62CA51F88BA366C93"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4337",
          "shortDescription" : {
            "text" : "Cross-Site Request Forgery"
          },
          "fullDescription" : {
            "text" : "The form post at ProductList.jsp line 60 must contain a user-specific secret in order to prevent an attacker from making unauthorized requests.\n\n\n"
          },
          "help" : {
            "text" : "A cross-site request forgery (CSRF) vulnerability occurs when:\n1. A Web application uses session cookies.\n\n2. The application acts on an HTTP request without verifying that the request was made with the user's consent.\n\n\nIn this case, the application generates HTTP request via a form post at ProductList.jsp line 60.\n\n\nA nonce is a cryptographic random value that is sent with a message to prevent replay attacks. If the request does not contain a nonce that proves its provenance, the code that handles the request is vulnerable to a CSRF attack (unless it does not change the state of the application). This means a Web application that uses session cookies has to take special precautions in order to ensure that an attacker can't trick users into submitting bogus requests. Imagine a Web application that allows administrators to create new accounts by submitting this form:\n\n\n&lt;form method=\"POST\" action=\"/new_user\" &gt;\n  Name of new user: &lt;input type=\"text\" name=\"username\"&gt;\n  Password for new user: &lt;input type=\"password\" name=\"user_passwd\"&gt;\n    &lt;input type=\"submit\" name=\"action\" value=\"Create User\"&gt;\n&lt;/form&gt;\n\n\nAn attacker might set up a Web site with the following:\n\n\n&lt;form method=\"POST\" action=\"http://www.example.com/new_user\"&gt;\n  &lt;input type=\"hidden\" name=\"username\" value=\"hacker\"&gt;\n  &lt;input type=\"hidden\" name=\"user_passwd\" value=\"hacked\"&gt;\n&lt;/form&gt;\n&lt;script&gt;\n  document.usr_form.submit();\n&lt;/script&gt;\n\n\nIf an administrator for example.com visits the malicious page while she has an active session on the site, she will unwittingly create an account for the attacker. This is a CSRF attack. It is possible because the application does not have a way to determine the provenance of the request. Any request could be a legitimate action chosen by the user or a faked action set up by an attacker. The attacker does not get to see the Web page that the bogus request generates, so the attack technique is only useful for requests that alter the state of the application.\n\nApplications that pass the session identifier in the URL rather than as a cookie do not have CSRF problems because there is no way for the attacker to access the session identifier and include it as part of the bogus request.\n\nCSRF is entry number five on the 2007 OWASP Top 10 list.\n\nApplications that use session cookies must include some piece of information in every form post that the back-end code can use to validate the provenance of the request. One way to do that is to include a random request identifier or nonce, as follows:\n\n\n  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, \"/new_user\");\n  body = addToPost(body, new_username);\n  body = addToPost(body, new_passwd);\n  body = addToPost(body, request_id);\n  rb.sendRequest(body, new NewAccountCallback(callback));\n\n\nThen the back-end logic can validate the request identifier before processing the rest of the form data. When possible, the request identifier should be unique to each server request rather than shared across every request for a particular session. As with session identifiers, the harder it is for an attacker to guess the request identifier, the harder it is to conduct a successful CSRF attack. The token should not be easily guessed and it should be protected in the same way that session tokens are protected, such as using SSLv3.\n\nAdditional mitigation techniques include:\n\nFramework protection: Most modern web application frameworks embed CSRF protection and they will automatically include and verify CSRF tokens.\nUse a Challenge-Response control: Forcing the customer to respond to a challenge sent by the server is a strong defense against CSRF. Some of the challenges that can be used for this purpose are: CAPTCHAs, password re-authentication and one-time tokens.\nCheck HTTP Referer/Origin headers: An attacker won't be able to spoof these headers while performing a CSRF attack. This makes these headers a useful method to prevent CSRF attacks.\nDouble-submit Session Cookie: Sending the session ID Cookie as a hidden form value in addition to the actual session ID Cookie is a good protection against CSRF attacks. The server will check both values and make sure they are identical before processing the rest of the form data. If an attacker submits a form in behalf of a user, he won't be able to modify the session ID cookie value as per the same-origin-policy.\nLimit Session Lifetime: When accessing protected resources using a CSRF attack, the attack will only be valid as long as the session ID sent as part of the attack is still valid on the server. Limiting the Session lifetime will reduce the probability of a successful attack.\n\nThe techniques described here can be defeated with XSS attacks. Effective CSRF mitigation includes XSS mitigation techniques.\n\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4337/?engineType=SCA&issue=A6AC08FCC5A79936441489A8A47E66ED"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4308",
          "shortDescription" : {
            "text" : "Cross-Site Request Forgery"
          },
          "fullDescription" : {
            "text" : "The form post at Registration.jsp line 24 must contain a user-specific secret in order to prevent an attacker from making unauthorized requests.\n\n\n"
          },
          "help" : {
            "text" : "A cross-site request forgery (CSRF) vulnerability occurs when:\n1. A Web application uses session cookies.\n\n2. The application acts on an HTTP request without verifying that the request was made with the user's consent.\n\n\nIn this case, the application generates HTTP request via a form post at Registration.jsp line 24.\n\n\nA nonce is a cryptographic random value that is sent with a message to prevent replay attacks. If the request does not contain a nonce that proves its provenance, the code that handles the request is vulnerable to a CSRF attack (unless it does not change the state of the application). This means a Web application that uses session cookies has to take special precautions in order to ensure that an attacker can't trick users into submitting bogus requests. Imagine a Web application that allows administrators to create new accounts by submitting this form:\n\n\n&lt;form method=\"POST\" action=\"/new_user\" &gt;\n  Name of new user: &lt;input type=\"text\" name=\"username\"&gt;\n  Password for new user: &lt;input type=\"password\" name=\"user_passwd\"&gt;\n    &lt;input type=\"submit\" name=\"action\" value=\"Create User\"&gt;\n&lt;/form&gt;\n\n\nAn attacker might set up a Web site with the following:\n\n\n&lt;form method=\"POST\" action=\"http://www.example.com/new_user\"&gt;\n  &lt;input type=\"hidden\" name=\"username\" value=\"hacker\"&gt;\n  &lt;input type=\"hidden\" name=\"user_passwd\" value=\"hacked\"&gt;\n&lt;/form&gt;\n&lt;script&gt;\n  document.usr_form.submit();\n&lt;/script&gt;\n\n\nIf an administrator for example.com visits the malicious page while she has an active session on the site, she will unwittingly create an account for the attacker. This is a CSRF attack. It is possible because the application does not have a way to determine the provenance of the request. Any request could be a legitimate action chosen by the user or a faked action set up by an attacker. The attacker does not get to see the Web page that the bogus request generates, so the attack technique is only useful for requests that alter the state of the application.\n\nApplications that pass the session identifier in the URL rather than as a cookie do not have CSRF problems because there is no way for the attacker to access the session identifier and include it as part of the bogus request.\n\nCSRF is entry number five on the 2007 OWASP Top 10 list.\n\nApplications that use session cookies must include some piece of information in every form post that the back-end code can use to validate the provenance of the request. One way to do that is to include a random request identifier or nonce, as follows:\n\n\n  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, \"/new_user\");\n  body = addToPost(body, new_username);\n  body = addToPost(body, new_passwd);\n  body = addToPost(body, request_id);\n  rb.sendRequest(body, new NewAccountCallback(callback));\n\n\nThen the back-end logic can validate the request identifier before processing the rest of the form data. When possible, the request identifier should be unique to each server request rather than shared across every request for a particular session. As with session identifiers, the harder it is for an attacker to guess the request identifier, the harder it is to conduct a successful CSRF attack. The token should not be easily guessed and it should be protected in the same way that session tokens are protected, such as using SSLv3.\n\nAdditional mitigation techniques include:\n\nFramework protection: Most modern web application frameworks embed CSRF protection and they will automatically include and verify CSRF tokens.\nUse a Challenge-Response control: Forcing the customer to respond to a challenge sent by the server is a strong defense against CSRF. Some of the challenges that can be used for this purpose are: CAPTCHAs, password re-authentication and one-time tokens.\nCheck HTTP Referer/Origin headers: An attacker won't be able to spoof these headers while performing a CSRF attack. This makes these headers a useful method to prevent CSRF attacks.\nDouble-submit Session Cookie: Sending the session ID Cookie as a hidden form value in addition to the actual session ID Cookie is a good protection against CSRF attacks. The server will check both values and make sure they are identical before processing the rest of the form data. If an attacker submits a form in behalf of a user, he won't be able to modify the session ID cookie value as per the same-origin-policy.\nLimit Session Lifetime: When accessing protected resources using a CSRF attack, the attack will only be valid as long as the session ID sent as part of the attack is still valid on the server. Limiting the Session lifetime will reduce the probability of a successful attack.\n\nThe techniques described here can be defeated with XSS attacks. Effective CSRF mitigation includes XSS mitigation techniques.\n\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4308/?engineType=SCA&issue=3186B9D5460F51CE8E9CBA615561D7E6"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4307",
          "shortDescription" : {
            "text" : "Cross-Site Request Forgery"
          },
          "fullDescription" : {
            "text" : "The form post at ResetPasswordInput.jsp line 24 must contain a user-specific secret in order to prevent an attacker from making unauthorized requests.\n\n\n"
          },
          "help" : {
            "text" : "A cross-site request forgery (CSRF) vulnerability occurs when:\n1. A Web application uses session cookies.\n\n2. The application acts on an HTTP request without verifying that the request was made with the user's consent.\n\n\nIn this case, the application generates HTTP request via a form post at ResetPasswordInput.jsp line 24.\n\n\nA nonce is a cryptographic random value that is sent with a message to prevent replay attacks. If the request does not contain a nonce that proves its provenance, the code that handles the request is vulnerable to a CSRF attack (unless it does not change the state of the application). This means a Web application that uses session cookies has to take special precautions in order to ensure that an attacker can't trick users into submitting bogus requests. Imagine a Web application that allows administrators to create new accounts by submitting this form:\n\n\n&lt;form method=\"POST\" action=\"/new_user\" &gt;\n  Name of new user: &lt;input type=\"text\" name=\"username\"&gt;\n  Password for new user: &lt;input type=\"password\" name=\"user_passwd\"&gt;\n    &lt;input type=\"submit\" name=\"action\" value=\"Create User\"&gt;\n&lt;/form&gt;\n\n\nAn attacker might set up a Web site with the following:\n\n\n&lt;form method=\"POST\" action=\"http://www.example.com/new_user\"&gt;\n  &lt;input type=\"hidden\" name=\"username\" value=\"hacker\"&gt;\n  &lt;input type=\"hidden\" name=\"user_passwd\" value=\"hacked\"&gt;\n&lt;/form&gt;\n&lt;script&gt;\n  document.usr_form.submit();\n&lt;/script&gt;\n\n\nIf an administrator for example.com visits the malicious page while she has an active session on the site, she will unwittingly create an account for the attacker. This is a CSRF attack. It is possible because the application does not have a way to determine the provenance of the request. Any request could be a legitimate action chosen by the user or a faked action set up by an attacker. The attacker does not get to see the Web page that the bogus request generates, so the attack technique is only useful for requests that alter the state of the application.\n\nApplications that pass the session identifier in the URL rather than as a cookie do not have CSRF problems because there is no way for the attacker to access the session identifier and include it as part of the bogus request.\n\nCSRF is entry number five on the 2007 OWASP Top 10 list.\n\nApplications that use session cookies must include some piece of information in every form post that the back-end code can use to validate the provenance of the request. One way to do that is to include a random request identifier or nonce, as follows:\n\n\n  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, \"/new_user\");\n  body = addToPost(body, new_username);\n  body = addToPost(body, new_passwd);\n  body = addToPost(body, request_id);\n  rb.sendRequest(body, new NewAccountCallback(callback));\n\n\nThen the back-end logic can validate the request identifier before processing the rest of the form data. When possible, the request identifier should be unique to each server request rather than shared across every request for a particular session. As with session identifiers, the harder it is for an attacker to guess the request identifier, the harder it is to conduct a successful CSRF attack. The token should not be easily guessed and it should be protected in the same way that session tokens are protected, such as using SSLv3.\n\nAdditional mitigation techniques include:\n\nFramework protection: Most modern web application frameworks embed CSRF protection and they will automatically include and verify CSRF tokens.\nUse a Challenge-Response control: Forcing the customer to respond to a challenge sent by the server is a strong defense against CSRF. Some of the challenges that can be used for this purpose are: CAPTCHAs, password re-authentication and one-time tokens.\nCheck HTTP Referer/Origin headers: An attacker won't be able to spoof these headers while performing a CSRF attack. This makes these headers a useful method to prevent CSRF attacks.\nDouble-submit Session Cookie: Sending the session ID Cookie as a hidden form value in addition to the actual session ID Cookie is a good protection against CSRF attacks. The server will check both values and make sure they are identical before processing the rest of the form data. If an attacker submits a form in behalf of a user, he won't be able to modify the session ID cookie value as per the same-origin-policy.\nLimit Session Lifetime: When accessing protected resources using a CSRF attack, the attack will only be valid as long as the session ID sent as part of the attack is still valid on the server. Limiting the Session lifetime will reduce the probability of a successful attack.\n\nThe techniques described here can be defeated with XSS attacks. Effective CSRF mitigation includes XSS mitigation techniques.\n\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4307/?engineType=SCA&issue=2BA169A83ED369B7A33D769A4CC4FBDD"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4339",
          "shortDescription" : {
            "text" : "Hidden Field"
          },
          "fullDescription" : {
            "text" : "A hidden form field is used in ResetPasswordInput.jsp on line 34.\n\n\n"
          },
          "help" : {
            "text" : "Programmers often trust the contents of hidden fields, expecting that users will not be able to view them or manipulate their contents. Attackers will violate these assumptions. They will examine the values written to hidden fields and alter them or replace the contents with attack data.\n\nExample: An &lt;input&gt; tag of type hidden indicates the use of a hidden field.\n\n&lt;input type=\"hidden\"&gt;\n\n\nIf hidden fields carry sensitive information, this information will be cached the same way the rest of the page is cached. This can lead to sensitive information being tucked away in the browser cache without the user's knowledge.\n\nExpect that attackers will study and decode all uses of hidden fields in the application. Treat hidden fields as untrusted input. Don't store information in hidden fields if the information should not be cached along with the rest of the page.\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4339/?engineType=SCA&issue=B95EC8BFA534F48CD6DC5F0DB7BD250F"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4340",
          "shortDescription" : {
            "text" : "Hidden Field"
          },
          "fullDescription" : {
            "text" : "A hidden form field is used in ResetPasswordInput.jsp on line 35.\n\n\n"
          },
          "help" : {
            "text" : "Programmers often trust the contents of hidden fields, expecting that users will not be able to view them or manipulate their contents. Attackers will violate these assumptions. They will examine the values written to hidden fields and alter them or replace the contents with attack data.\n\nExample: An &lt;input&gt; tag of type hidden indicates the use of a hidden field.\n\n&lt;input type=\"hidden\"&gt;\n\n\nIf hidden fields carry sensitive information, this information will be cached the same way the rest of the page is cached. This can lead to sensitive information being tucked away in the browser cache without the user's knowledge.\n\nExpect that attackers will study and decode all uses of hidden fields in the application. Treat hidden fields as untrusted input. Don't store information in hidden fields if the information should not be cached along with the rest of the page.\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4340/?engineType=SCA&issue=B95EC8BFA534F48CD6DC5F0DB7BD2510"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4323",
          "shortDescription" : {
            "text" : "Cross-Site Request Forgery"
          },
          "fullDescription" : {
            "text" : "The form post at ResetPasswordStart.jsp line 24 must contain a user-specific secret in order to prevent an attacker from making unauthorized requests.\n\n\n"
          },
          "help" : {
            "text" : "A cross-site request forgery (CSRF) vulnerability occurs when:\n1. A Web application uses session cookies.\n\n2. The application acts on an HTTP request without verifying that the request was made with the user's consent.\n\n\nIn this case, the application generates HTTP request via a form post at ResetPasswordStart.jsp line 24.\n\n\nA nonce is a cryptographic random value that is sent with a message to prevent replay attacks. If the request does not contain a nonce that proves its provenance, the code that handles the request is vulnerable to a CSRF attack (unless it does not change the state of the application). This means a Web application that uses session cookies has to take special precautions in order to ensure that an attacker can't trick users into submitting bogus requests. Imagine a Web application that allows administrators to create new accounts by submitting this form:\n\n\n&lt;form method=\"POST\" action=\"/new_user\" &gt;\n  Name of new user: &lt;input type=\"text\" name=\"username\"&gt;\n  Password for new user: &lt;input type=\"password\" name=\"user_passwd\"&gt;\n    &lt;input type=\"submit\" name=\"action\" value=\"Create User\"&gt;\n&lt;/form&gt;\n\n\nAn attacker might set up a Web site with the following:\n\n\n&lt;form method=\"POST\" action=\"http://www.example.com/new_user\"&gt;\n  &lt;input type=\"hidden\" name=\"username\" value=\"hacker\"&gt;\n  &lt;input type=\"hidden\" name=\"user_passwd\" value=\"hacked\"&gt;\n&lt;/form&gt;\n&lt;script&gt;\n  document.usr_form.submit();\n&lt;/script&gt;\n\n\nIf an administrator for example.com visits the malicious page while she has an active session on the site, she will unwittingly create an account for the attacker. This is a CSRF attack. It is possible because the application does not have a way to determine the provenance of the request. Any request could be a legitimate action chosen by the user or a faked action set up by an attacker. The attacker does not get to see the Web page that the bogus request generates, so the attack technique is only useful for requests that alter the state of the application.\n\nApplications that pass the session identifier in the URL rather than as a cookie do not have CSRF problems because there is no way for the attacker to access the session identifier and include it as part of the bogus request.\n\nCSRF is entry number five on the 2007 OWASP Top 10 list.\n\nApplications that use session cookies must include some piece of information in every form post that the back-end code can use to validate the provenance of the request. One way to do that is to include a random request identifier or nonce, as follows:\n\n\n  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, \"/new_user\");\n  body = addToPost(body, new_username);\n  body = addToPost(body, new_passwd);\n  body = addToPost(body, request_id);\n  rb.sendRequest(body, new NewAccountCallback(callback));\n\n\nThen the back-end logic can validate the request identifier before processing the rest of the form data. When possible, the request identifier should be unique to each server request rather than shared across every request for a particular session. As with session identifiers, the harder it is for an attacker to guess the request identifier, the harder it is to conduct a successful CSRF attack. The token should not be easily guessed and it should be protected in the same way that session tokens are protected, such as using SSLv3.\n\nAdditional mitigation techniques include:\n\nFramework protection: Most modern web application frameworks embed CSRF protection and they will automatically include and verify CSRF tokens.\nUse a Challenge-Response control: Forcing the customer to respond to a challenge sent by the server is a strong defense against CSRF. Some of the challenges that can be used for this purpose are: CAPTCHAs, password re-authentication and one-time tokens.\nCheck HTTP Referer/Origin headers: An attacker won't be able to spoof these headers while performing a CSRF attack. This makes these headers a useful method to prevent CSRF attacks.\nDouble-submit Session Cookie: Sending the session ID Cookie as a hidden form value in addition to the actual session ID Cookie is a good protection against CSRF attacks. The server will check both values and make sure they are identical before processing the rest of the form data. If an attacker submits a form in behalf of a user, he won't be able to modify the session ID cookie value as per the same-origin-policy.\nLimit Session Lifetime: When accessing protected resources using a CSRF attack, the attack will only be valid as long as the session ID sent as part of the attack is still valid on the server. Limiting the Session lifetime will reduce the probability of a successful attack.\n\nThe techniques described here can be defeated with XSS attacks. Effective CSRF mitigation includes XSS mitigation techniques.\n\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4323/?engineType=SCA&issue=735FCC38444C095798196AC03D6FDAB2"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4353",
          "shortDescription" : {
            "text" : "Cross-Site Request Forgery"
          },
          "fullDescription" : {
            "text" : "The form post at UserEdit.jsp line 21 must contain a user-specific secret in order to prevent an attacker from making unauthorized requests.\n\n\n"
          },
          "help" : {
            "text" : "A cross-site request forgery (CSRF) vulnerability occurs when:\n1. A Web application uses session cookies.\n\n2. The application acts on an HTTP request without verifying that the request was made with the user's consent.\n\n\nIn this case, the application generates HTTP request via a form post at UserEdit.jsp line 21.\n\n\nA nonce is a cryptographic random value that is sent with a message to prevent replay attacks. If the request does not contain a nonce that proves its provenance, the code that handles the request is vulnerable to a CSRF attack (unless it does not change the state of the application). This means a Web application that uses session cookies has to take special precautions in order to ensure that an attacker can't trick users into submitting bogus requests. Imagine a Web application that allows administrators to create new accounts by submitting this form:\n\n\n&lt;form method=\"POST\" action=\"/new_user\" &gt;\n  Name of new user: &lt;input type=\"text\" name=\"username\"&gt;\n  Password for new user: &lt;input type=\"password\" name=\"user_passwd\"&gt;\n    &lt;input type=\"submit\" name=\"action\" value=\"Create User\"&gt;\n&lt;/form&gt;\n\n\nAn attacker might set up a Web site with the following:\n\n\n&lt;form method=\"POST\" action=\"http://www.example.com/new_user\"&gt;\n  &lt;input type=\"hidden\" name=\"username\" value=\"hacker\"&gt;\n  &lt;input type=\"hidden\" name=\"user_passwd\" value=\"hacked\"&gt;\n&lt;/form&gt;\n&lt;script&gt;\n  document.usr_form.submit();\n&lt;/script&gt;\n\n\nIf an administrator for example.com visits the malicious page while she has an active session on the site, she will unwittingly create an account for the attacker. This is a CSRF attack. It is possible because the application does not have a way to determine the provenance of the request. Any request could be a legitimate action chosen by the user or a faked action set up by an attacker. The attacker does not get to see the Web page that the bogus request generates, so the attack technique is only useful for requests that alter the state of the application.\n\nApplications that pass the session identifier in the URL rather than as a cookie do not have CSRF problems because there is no way for the attacker to access the session identifier and include it as part of the bogus request.\n\nCSRF is entry number five on the 2007 OWASP Top 10 list.\n\nApplications that use session cookies must include some piece of information in every form post that the back-end code can use to validate the provenance of the request. One way to do that is to include a random request identifier or nonce, as follows:\n\n\n  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, \"/new_user\");\n  body = addToPost(body, new_username);\n  body = addToPost(body, new_passwd);\n  body = addToPost(body, request_id);\n  rb.sendRequest(body, new NewAccountCallback(callback));\n\n\nThen the back-end logic can validate the request identifier before processing the rest of the form data. When possible, the request identifier should be unique to each server request rather than shared across every request for a particular session. As with session identifiers, the harder it is for an attacker to guess the request identifier, the harder it is to conduct a successful CSRF attack. The token should not be easily guessed and it should be protected in the same way that session tokens are protected, such as using SSLv3.\n\nAdditional mitigation techniques include:\n\nFramework protection: Most modern web application frameworks embed CSRF protection and they will automatically include and verify CSRF tokens.\nUse a Challenge-Response control: Forcing the customer to respond to a challenge sent by the server is a strong defense against CSRF. Some of the challenges that can be used for this purpose are: CAPTCHAs, password re-authentication and one-time tokens.\nCheck HTTP Referer/Origin headers: An attacker won't be able to spoof these headers while performing a CSRF attack. This makes these headers a useful method to prevent CSRF attacks.\nDouble-submit Session Cookie: Sending the session ID Cookie as a hidden form value in addition to the actual session ID Cookie is a good protection against CSRF attacks. The server will check both values and make sure they are identical before processing the rest of the form data. If an attacker submits a form in behalf of a user, he won't be able to modify the session ID cookie value as per the same-origin-policy.\nLimit Session Lifetime: When accessing protected resources using a CSRF attack, the attack will only be valid as long as the session ID sent as part of the attack is still valid on the server. Limiting the Session lifetime will reduce the probability of a successful attack.\n\nThe techniques described here can be defeated with XSS attacks. Effective CSRF mitigation includes XSS mitigation techniques.\n\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4353/?engineType=SCA&issue=F3F2711DFA11EB2716262F1C6823A3C8"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4313",
          "shortDescription" : {
            "text" : "Hidden Field"
          },
          "fullDescription" : {
            "text" : "A hidden form field is used in UserEdit.jsp on line 22.\n\n\n"
          },
          "help" : {
            "text" : "Programmers often trust the contents of hidden fields, expecting that users will not be able to view them or manipulate their contents. Attackers will violate these assumptions. They will examine the values written to hidden fields and alter them or replace the contents with attack data.\n\nExample: An &lt;input&gt; tag of type hidden indicates the use of a hidden field.\n\n&lt;input type=\"hidden\"&gt;\n\n\nIf hidden fields carry sensitive information, this information will be cached the same way the rest of the page is cached. This can lead to sensitive information being tucked away in the browser cache without the user's knowledge.\n\nExpect that attackers will study and decode all uses of hidden fields in the application. Treat hidden fields as untrusted input. Don't store information in hidden fields if the information should not be cached along with the rest of the page.\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4313/?engineType=SCA&issue=47EEB7D3C816D74B7099C0EE556E45AA"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4318",
          "shortDescription" : {
            "text" : "Cross-Site Request Forgery"
          },
          "fullDescription" : {
            "text" : "The form post at UserSearch.jsp line 21 must contain a user-specific secret in order to prevent an attacker from making unauthorized requests.\n\n\n"
          },
          "help" : {
            "text" : "A cross-site request forgery (CSRF) vulnerability occurs when:\n1. A Web application uses session cookies.\n\n2. The application acts on an HTTP request without verifying that the request was made with the user's consent.\n\n\nIn this case, the application generates HTTP request via a form post at UserSearch.jsp line 21.\n\n\nA nonce is a cryptographic random value that is sent with a message to prevent replay attacks. If the request does not contain a nonce that proves its provenance, the code that handles the request is vulnerable to a CSRF attack (unless it does not change the state of the application). This means a Web application that uses session cookies has to take special precautions in order to ensure that an attacker can't trick users into submitting bogus requests. Imagine a Web application that allows administrators to create new accounts by submitting this form:\n\n\n&lt;form method=\"POST\" action=\"/new_user\" &gt;\n  Name of new user: &lt;input type=\"text\" name=\"username\"&gt;\n  Password for new user: &lt;input type=\"password\" name=\"user_passwd\"&gt;\n    &lt;input type=\"submit\" name=\"action\" value=\"Create User\"&gt;\n&lt;/form&gt;\n\n\nAn attacker might set up a Web site with the following:\n\n\n&lt;form method=\"POST\" action=\"http://www.example.com/new_user\"&gt;\n  &lt;input type=\"hidden\" name=\"username\" value=\"hacker\"&gt;\n  &lt;input type=\"hidden\" name=\"user_passwd\" value=\"hacked\"&gt;\n&lt;/form&gt;\n&lt;script&gt;\n  document.usr_form.submit();\n&lt;/script&gt;\n\n\nIf an administrator for example.com visits the malicious page while she has an active session on the site, she will unwittingly create an account for the attacker. This is a CSRF attack. It is possible because the application does not have a way to determine the provenance of the request. Any request could be a legitimate action chosen by the user or a faked action set up by an attacker. The attacker does not get to see the Web page that the bogus request generates, so the attack technique is only useful for requests that alter the state of the application.\n\nApplications that pass the session identifier in the URL rather than as a cookie do not have CSRF problems because there is no way for the attacker to access the session identifier and include it as part of the bogus request.\n\nCSRF is entry number five on the 2007 OWASP Top 10 list.\n\nApplications that use session cookies must include some piece of information in every form post that the back-end code can use to validate the provenance of the request. One way to do that is to include a random request identifier or nonce, as follows:\n\n\n  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, \"/new_user\");\n  body = addToPost(body, new_username);\n  body = addToPost(body, new_passwd);\n  body = addToPost(body, request_id);\n  rb.sendRequest(body, new NewAccountCallback(callback));\n\n\nThen the back-end logic can validate the request identifier before processing the rest of the form data. When possible, the request identifier should be unique to each server request rather than shared across every request for a particular session. As with session identifiers, the harder it is for an attacker to guess the request identifier, the harder it is to conduct a successful CSRF attack. The token should not be easily guessed and it should be protected in the same way that session tokens are protected, such as using SSLv3.\n\nAdditional mitigation techniques include:\n\nFramework protection: Most modern web application frameworks embed CSRF protection and they will automatically include and verify CSRF tokens.\nUse a Challenge-Response control: Forcing the customer to respond to a challenge sent by the server is a strong defense against CSRF. Some of the challenges that can be used for this purpose are: CAPTCHAs, password re-authentication and one-time tokens.\nCheck HTTP Referer/Origin headers: An attacker won't be able to spoof these headers while performing a CSRF attack. This makes these headers a useful method to prevent CSRF attacks.\nDouble-submit Session Cookie: Sending the session ID Cookie as a hidden form value in addition to the actual session ID Cookie is a good protection against CSRF attacks. The server will check both values and make sure they are identical before processing the rest of the form data. If an attacker submits a form in behalf of a user, he won't be able to modify the session ID cookie value as per the same-origin-policy.\nLimit Session Lifetime: When accessing protected resources using a CSRF attack, the attack will only be valid as long as the session ID sent as part of the attack is still valid on the server. Limiting the Session lifetime will reduce the probability of a successful attack.\n\nThe techniques described here can be defeated with XSS attacks. Effective CSRF mitigation includes XSS mitigation techniques.\n\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4318/?engineType=SCA&issue=592B0DD2D4A96EE1F188970758EDA711"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4329",
          "shortDescription" : {
            "text" : "System Information Leak: HTML Comment in JSP"
          },
          "fullDescription" : {
            "text" : "Any information revealed in the HTML comment at Footer.jsp line 17 could help an adversary learn about the system and form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "HTML comments provide an attacker with an easy source of information about a dynamically generated web page.\n\nExample 1:\n\n\n&lt;!-- TBD: this needs a security audit --&gt;\n&lt;form method=\"POST\" action=\"recalcOrbit\"&gt;\n...\n\n\nEven comments that seem innocuous may be useful to someone trying to understand the way the system is built.\n\nAdd the following configuration to your web.xml file, which will exclude HTML comments from the content sent to the user:\n\n&lt;web-app&gt;\n  ...\n  &lt;context-param&gt;\n      &lt;param-name&gt;facelets.SKIP_COMMENTS&lt;/param-name&gt;\n      &lt;param-value&gt;true&lt;/param-value&gt;\n  &lt;/context-param&gt;\n  ...\n\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4329/?engineType=SCA&issue=8E5F76C9D7D6691AD337CB3D264002AB"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4321",
          "shortDescription" : {
            "text" : "System Information Leak: HTML Comment in JSP"
          },
          "fullDescription" : {
            "text" : "Any information revealed in the HTML comment at Head.jsp line 5 could help an adversary learn about the system and form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "HTML comments provide an attacker with an easy source of information about a dynamically generated web page.\n\nExample 1:\n\n\n&lt;!-- TBD: this needs a security audit --&gt;\n&lt;form method=\"POST\" action=\"recalcOrbit\"&gt;\n...\n\n\nEven comments that seem innocuous may be useful to someone trying to understand the way the system is built.\n\nAdd the following configuration to your web.xml file, which will exclude HTML comments from the content sent to the user:\n\n&lt;web-app&gt;\n  ...\n  &lt;context-param&gt;\n      &lt;param-name&gt;facelets.SKIP_COMMENTS&lt;/param-name&gt;\n      &lt;param-value&gt;true&lt;/param-value&gt;\n  &lt;/context-param&gt;\n  ...\n\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4321/?engineType=SCA&issue=64F8FD3C5EC4F9EDBF4E5094E2923346"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4338",
          "shortDescription" : {
            "text" : "Hardcoded Domain in HTML"
          },
          "fullDescription" : {
            "text" : "The file Head.jsp references a script using a hardcoded domain name on line 7. If attackers compromise the domain, they will have malicious code on this page.\n\n\n"
          },
          "help" : {
            "text" : "Including executable content from another web site is a risky proposition. It ties the security of your site to the security of the other site.\n\nExample: Consider the following script tag.\n\n  &lt;script src=\"http://www.example.com/js/fancyWidget.js\"&gt;&lt;/script&gt;\n\n\nIf this tag appears on a web site other than www.example.com, then the site is dependent upon www.example.com to serve up correct and non-malicious code. If attackers can compromise www.example.com, then they can alter the contents of fancyWidget.js to subvert the security of the site. They could, for example, add code to fancyWidget.js to steal a user's confidential data.\n\nKeep control over the code your web pages invoke. Do not include scripts or other artifacts from third-party sites.\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4338/?engineType=SCA&issue=B42D3BC345715BC780882BE260A4595B"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4350",
          "shortDescription" : {
            "text" : "Dynamic Code Evaluation: Insecure Transport"
          },
          "fullDescription" : {
            "text" : "The file Head.jsp on line 7 loads a script over an unencrypted channel.\n\n\n"
          },
          "help" : {
            "text" : "Including executable content from a website over an unencrypted channel enables an attacker to perform a man-in-the-middle (MiTM) attack. This enables an attacker to load their own content that is executed as if it was part of the original website.\n\nExample: Consider the following script tag:\n\n&lt;script src=\"http://www.example.com/js/fancyWidget.js\"&gt;&lt;/script&gt;\n\n\nIf an attacker is listening to the network traffic between the user and the server, the attacker can imitate or manipulate the content from www.example.com to load their own JavaScript.\n\nControl the code that your web pages load and if the code is coming from a separate domain, make sure the code is always loaded over a secure connection. Whenever possible, avoid including scripts or other artifacts from third-party sites.\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4350/?engineType=SCA&issue=E275D60D42B32BAB6E53FE531B8E3F26"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "4325",
          "shortDescription" : {
            "text" : "System Information Leak: HTML Comment in JSP"
          },
          "fullDescription" : {
            "text" : "Any information revealed in the HTML comment at Navigation.jsp line 37 could help an adversary learn about the system and form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "HTML comments provide an attacker with an easy source of information about a dynamically generated web page.\n\nExample 1:\n\n\n&lt;!-- TBD: this needs a security audit --&gt;\n&lt;form method=\"POST\" action=\"recalcOrbit\"&gt;\n...\n\n\nEven comments that seem innocuous may be useful to someone trying to understand the way the system is built.\n\nAdd the following configuration to your web.xml file, which will exclude HTML comments from the content sent to the user:\n\n&lt;web-app&gt;\n  ...\n  &lt;context-param&gt;\n      &lt;param-name&gt;facelets.SKIP_COMMENTS&lt;/param-name&gt;\n      &lt;param-value&gt;true&lt;/param-value&gt;\n  &lt;/context-param&gt;\n  ...\n\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4325/?engineType=SCA&issue=7A47D2D51B2E8B627C8C43E37B499C6A"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4306",
          "shortDescription" : {
            "text" : "Cross-Site Request Forgery"
          },
          "fullDescription" : {
            "text" : "The form post at Login.jsp line 9 must contain a user-specific secret in order to prevent an attacker from making unauthorized requests.\n\n\n"
          },
          "help" : {
            "text" : "A cross-site request forgery (CSRF) vulnerability occurs when:\n1. A Web application uses session cookies.\n\n2. The application acts on an HTTP request without verifying that the request was made with the user's consent.\n\n\nIn this case, the application generates HTTP request via a form post at Login.jsp line 9.\n\n\nA nonce is a cryptographic random value that is sent with a message to prevent replay attacks. If the request does not contain a nonce that proves its provenance, the code that handles the request is vulnerable to a CSRF attack (unless it does not change the state of the application). This means a Web application that uses session cookies has to take special precautions in order to ensure that an attacker can't trick users into submitting bogus requests. Imagine a Web application that allows administrators to create new accounts by submitting this form:\n\n\n&lt;form method=\"POST\" action=\"/new_user\" &gt;\n  Name of new user: &lt;input type=\"text\" name=\"username\"&gt;\n  Password for new user: &lt;input type=\"password\" name=\"user_passwd\"&gt;\n    &lt;input type=\"submit\" name=\"action\" value=\"Create User\"&gt;\n&lt;/form&gt;\n\n\nAn attacker might set up a Web site with the following:\n\n\n&lt;form method=\"POST\" action=\"http://www.example.com/new_user\"&gt;\n  &lt;input type=\"hidden\" name=\"username\" value=\"hacker\"&gt;\n  &lt;input type=\"hidden\" name=\"user_passwd\" value=\"hacked\"&gt;\n&lt;/form&gt;\n&lt;script&gt;\n  document.usr_form.submit();\n&lt;/script&gt;\n\n\nIf an administrator for example.com visits the malicious page while she has an active session on the site, she will unwittingly create an account for the attacker. This is a CSRF attack. It is possible because the application does not have a way to determine the provenance of the request. Any request could be a legitimate action chosen by the user or a faked action set up by an attacker. The attacker does not get to see the Web page that the bogus request generates, so the attack technique is only useful for requests that alter the state of the application.\n\nApplications that pass the session identifier in the URL rather than as a cookie do not have CSRF problems because there is no way for the attacker to access the session identifier and include it as part of the bogus request.\n\nCSRF is entry number five on the 2007 OWASP Top 10 list.\n\nApplications that use session cookies must include some piece of information in every form post that the back-end code can use to validate the provenance of the request. One way to do that is to include a random request identifier or nonce, as follows:\n\n\n  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, \"/new_user\");\n  body = addToPost(body, new_username);\n  body = addToPost(body, new_passwd);\n  body = addToPost(body, request_id);\n  rb.sendRequest(body, new NewAccountCallback(callback));\n\n\nThen the back-end logic can validate the request identifier before processing the rest of the form data. When possible, the request identifier should be unique to each server request rather than shared across every request for a particular session. As with session identifiers, the harder it is for an attacker to guess the request identifier, the harder it is to conduct a successful CSRF attack. The token should not be easily guessed and it should be protected in the same way that session tokens are protected, such as using SSLv3.\n\nAdditional mitigation techniques include:\n\nFramework protection: Most modern web application frameworks embed CSRF protection and they will automatically include and verify CSRF tokens.\nUse a Challenge-Response control: Forcing the customer to respond to a challenge sent by the server is a strong defense against CSRF. Some of the challenges that can be used for this purpose are: CAPTCHAs, password re-authentication and one-time tokens.\nCheck HTTP Referer/Origin headers: An attacker won't be able to spoof these headers while performing a CSRF attack. This makes these headers a useful method to prevent CSRF attacks.\nDouble-submit Session Cookie: Sending the session ID Cookie as a hidden form value in addition to the actual session ID Cookie is a good protection against CSRF attacks. The server will check both values and make sure they are identical before processing the rest of the form data. If an attacker submits a form in behalf of a user, he won't be able to modify the session ID cookie value as per the same-origin-policy.\nLimit Session Lifetime: When accessing protected resources using a CSRF attack, the attack will only be valid as long as the session ID sent as part of the attack is still valid on the server. Limiting the Session lifetime will reduce the probability of a successful attack.\n\nThe techniques described here can be defeated with XSS attacks. Effective CSRF mitigation includes XSS mitigation techniques.\n\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4306/?engineType=SCA&issue=1FCC1E56FEB6B3696535A573237EC793"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4310",
          "shortDescription" : {
            "text" : "J2EE Misconfiguration: Missing Error Handling"
          },
          "fullDescription" : {
            "text" : "A web application must define default error pages in order to prevent attackers from mining information from the application container's built-in error response.\n\n\n"
          },
          "help" : {
            "text" : "When an attacker explores a web site looking for vulnerabilities, the amount of information that the site provides is crucial to the eventual success or failure of any attempted attacks. If the application shows the attacker a stack trace, it relinquishes information that makes the attacker's job significantly easier. For example, a stack trace might show the attacker a malformed SQL query string, the type of database being used, and the version of the application container. This information enables the attacker to target known vulnerabilities in these components.\n\nThe application configuration should specify a default error page in order to guarantee that the application will never leak error messages to an attacker. Handling standard HTTP error codes is useful and user-friendly in addition to being a good security practice, and a good configuration will also define a last-chance error handler that catches any exception that could possibly be thrown by the application.\n\nA web application must be configured with a default error page. Your web.xml should include at least the following entries:\n\n\n&lt;error-page&gt;\n   &lt;exception-type&gt;java.lang.Throwable&lt;/exception-type&gt;\n&lt;location&gt;/error.jsp&lt;/location&gt;\n&lt;/error-page&gt;\n&lt;error-page&gt;\n   &lt;error-code&gt;404&lt;/error-code&gt;\n&lt;location&gt;/error.jsp&lt;/location&gt;\n&lt;/error-page&gt;\n&lt;error-page&gt;\n   &lt;error-code&gt;500&lt;/error-code&gt;\n&lt;location&gt;/error.jsp&lt;/location&gt;\n&lt;/error-page&gt;\n\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4310/?engineType=SCA&issue=399A248E35AE0FBB04255DE45FA9754C"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "4343",
          "shortDescription" : {
            "text" : "J2EE Misconfiguration: Excessive Session Timeout"
          },
          "fullDescription" : {
            "text" : "An overly long session timeout gives attackers more time to potentially compromise user accounts.\n\n\n"
          },
          "help" : {
            "text" : "The longer a session stays open, the larger the window of opportunity an attacker has to compromise user accounts. While a session remains active, an attacker may be able to brute-force a user's password, crack a user's wireless encryption key, or commandeer a session from an open browser. Longer session timeouts can also prevent memory from being released and eventually result in a denial of service if a sufficiently large number of sessions are created.\n\nExample 1: If the session timeout is zero or less than zero, the session never expires. The following example shows a session timeout set to -1, which will cause the session to remain active indefinitely.\n\n&lt;session-config&gt;\n    &lt;session-timeout&gt;-1&lt;/session-timeout&gt;\n&lt;/session-config&gt;\n\n\nThe &lt;session-timeout&gt; tag defines the default session timeout interval for all sessions in the web application. If the &lt;session-timeout&gt; tag is missing, it is left to the container to set the default timeout.\r\nThis category was derived from the Cigital Java Rulepack.\n\nSet a session timeout that is 30 minutes or less, which both allows users to interact with the application over a period of time and provides a reasonable bound for the window of attack.\n\nExample 2: The following example sets the session timeout to 20 minutes.\n\n&lt;session-config&gt;\n  &lt;session-timeout&gt;20&lt;/session-timeout&gt;\n&lt;/session-config&gt;\n\n\n\n\n\nFor more information, see http://192.168.65.213:8080/ssc/html/ssc/version/10/fix/4343/?engineType=SCA&issue=C2F39B963AB1AFACD8D57325EEAF747F"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        } ]
      }
    },
    "results" : [ {
      "ruleId" : "4344",
      "message" : {
        "text" : "The Dockerfile does not specify a USER, so it defaults to running with a root user.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "C30558D67920422BF94AC1350B33CF49"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "Dockerfile"
          },
          "region" : {
            "startLine" : 1,
            "endLine" : 1,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "Dockerfile:1 - FROM"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Dockerfile"
                },
                "region" : {
                  "startLine" : 1
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "Dockerfile:1 - FROM"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Dockerfile"
                },
                "region" : {
                  "startLine" : 1
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4333",
      "message" : {
        "text" : "Hardcoded passwords can compromise system security in a way that is difficult to remedy.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "A1A174E0B163082FF1E5CA9CC2180B96"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "docker-compose.yml"
          },
          "region" : {
            "startLine" : 7,
            "endLine" : 7,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "docker-compose.yml:7 - ConfigPair"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "docker-compose.yml"
                },
                "region" : {
                  "startLine" : 7
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "docker-compose.yml:7 - ConfigPair"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "docker-compose.yml"
                },
                "region" : {
                  "startLine" : 7
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4334",
      "message" : {
        "text" : "Hardcoded passwords can compromise system security in a way that is difficult to remedy.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "A1A174E0B163082FF1E5CA9CC2180B97"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "docker-compose.yml"
          },
          "region" : {
            "startLine" : 16,
            "endLine" : 16,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "docker-compose.yml:16 - ConfigPair"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "docker-compose.yml"
                },
                "region" : {
                  "startLine" : 16
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "docker-compose.yml:16 - ConfigPair"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "docker-compose.yml"
                },
                "region" : {
                  "startLine" : 16
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4326",
      "message" : {
        "text" : "This maven build script relies on external sources, which could allow an attacker to insert malicious code into the final product or to take control of the build machine.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "87E3EC5CC8154C006783CC461A6DDEEB"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "pom.xml"
          },
          "region" : {
            "startLine" : 3,
            "endLine" : 3,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "pom.xml:3 - //project/repositories"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "pom.xml"
                },
                "region" : {
                  "startLine" : 3
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "pom.xml:3 - //project/repositories"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "pom.xml"
                },
                "region" : {
                  "startLine" : 3
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4327",
      "message" : {
        "text" : "Revealing system data or debugging information helps an adversary learn about the system and form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "8A3F2FE7439259154AADB746A911E394"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "pom.xml"
          },
          "region" : {
            "startLine" : 28,
            "endLine" : 28,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "pom.xml:28"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "pom.xml"
                },
                "region" : {
                  "startLine" : 28
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "pom.xml:28"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "pom.xml"
                },
                "region" : {
                  "startLine" : 28
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4330",
      "message" : {
        "text" : "Struts2 Actions should utilize the Struts Validation framework to prevent vulnerabilities that result from unchecked input.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "91EB85F977247B89E4C347CCDC9B7C9E"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/appsecco/dvja/controllers/ApiAction.java"
          },
          "region" : {
            "startLine" : 14,
            "endLine" : 14,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "ApiAction.java:14 - Class: ApiAction"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/ApiAction.java"
                },
                "region" : {
                  "startLine" : 14
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "ApiAction.java:14 - Class: ApiAction"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/ApiAction.java"
                },
                "region" : {
                  "startLine" : 14
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4358",
      "message" : {
        "text" : "The function renderText() in BaseController.java reveals system data or debug information by calling printStackTrace() on line 62. The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "FD12FE6FC705F7DEEFC8029D24CA1A81"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/appsecco/dvja/controllers/BaseController.java"
          },
          "region" : {
            "startLine" : 62,
            "endLine" : 62,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "BaseController.java:62 - printStackTrace()"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/BaseController.java"
                },
                "region" : {
                  "startLine" : 62
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "BaseController.java:62 - printStackTrace()"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/BaseController.java"
                },
                "region" : {
                  "startLine" : 62
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4336",
      "message" : {
        "text" : "The function renderJSON() in BaseController.java reveals system data or debug information by calling printStackTrace() on line 75. The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "A64622E544ACEF0FF2CBC91A944348D5"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/appsecco/dvja/controllers/BaseController.java"
          },
          "region" : {
            "startLine" : 75,
            "endLine" : 75,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "BaseController.java:75 - printStackTrace()"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/BaseController.java"
                },
                "region" : {
                  "startLine" : 75
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "BaseController.java:75 - printStackTrace()"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/BaseController.java"
                },
                "region" : {
                  "startLine" : 75
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4346",
      "message" : {
        "text" : "Struts2 Actions should utilize the Struts Validation framework to prevent vulnerabilities that result from unchecked input.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "C4FDB000933A03F4805D7E23391F9A7E"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/appsecco/dvja/controllers/Home.java"
          },
          "region" : {
            "startLine" : 8,
            "endLine" : 8,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "Home.java:8 - Class: Home"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/Home.java"
                },
                "region" : {
                  "startLine" : 8
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "Home.java:8 - Class: Home"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/Home.java"
                },
                "region" : {
                  "startLine" : 8
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4311",
      "message" : {
        "text" : "An Action Field was found without a corresponding validation definition.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "39F250AE15CAC387EDD5C941ECCA7EA1"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/appsecco/dvja/controllers/Login.java"
          },
          "region" : {
            "startLine" : 9,
            "endLine" : 9,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "Login.java:9 - Field: userAuthenticationService"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/Login.java"
                },
                "region" : {
                  "startLine" : 9
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "Login.java:9 - Field: userAuthenticationService"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/Login.java"
                },
                "region" : {
                  "startLine" : 9
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4303",
      "message" : {
        "text" : "An Action Field was found without a corresponding validation definition.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "1C9ECCFE853A32DD09D4BBAA03565655"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/appsecco/dvja/controllers/Login.java"
          },
          "region" : {
            "startLine" : 11,
            "endLine" : 11,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "Login.java:11 - Field: login"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/Login.java"
                },
                "region" : {
                  "startLine" : 11
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "Login.java:11 - Field: login"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/Login.java"
                },
                "region" : {
                  "startLine" : 11
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4316",
      "message" : {
        "text" : "Struts2 Actions should utilize the Struts Validation framework to prevent vulnerabilities that result from unchecked input.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "5524969D03F1852D9793B193974B507F"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/appsecco/dvja/controllers/PingAction.java"
          },
          "region" : {
            "startLine" : 9,
            "endLine" : 9,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "PingAction.java:9 - Class: PingAction"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/PingAction.java"
                },
                "region" : {
                  "startLine" : 9
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "PingAction.java:9 - Class: PingAction"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/PingAction.java"
                },
                "region" : {
                  "startLine" : 9
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4320",
      "message" : {
        "text" : "The catch block at PingAction.java line 36 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "5E6159E0C738CB312E011A8545947D3C"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/appsecco/dvja/controllers/PingAction.java"
          },
          "region" : {
            "startLine" : 36,
            "endLine" : 36,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "PingAction.java:36 - CatchBlock"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/PingAction.java"
                },
                "region" : {
                  "startLine" : 36
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "PingAction.java:36 - CatchBlock"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/PingAction.java"
                },
                "region" : {
                  "startLine" : 36
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4317",
      "message" : {
        "text" : "The method doExecCommand() in PingAction.java calls exec() with a command built from untrusted data. This call can cause the program to execute malicious commands on behalf of an attacker.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "55CD8DAA81FEA1C3CC22A6AAFB970A94"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/appsecco/dvja/controllers/PingAction.java"
          },
          "region" : {
            "startLine" : 46,
            "endLine" : 46,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "PingAction.java:18 - setAddress(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/PingAction.java"
                },
                "region" : {
                  "startLine" : 18
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "PingAction.java:46 - exec(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/PingAction.java"
                },
                "region" : {
                  "startLine" : 46
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "PingAction.java:18 - setAddress(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/PingAction.java"
                },
                "region" : {
                  "startLine" : 18
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "PingAction.java:19 - Assignment to this.address"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/PingAction.java"
                },
                "region" : {
                  "startLine" : 19
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "PingAction.java:15 - Read this.address"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/PingAction.java"
                },
                "region" : {
                  "startLine" : 15
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "PingAction.java:15 - Return this.address"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/PingAction.java"
                },
                "region" : {
                  "startLine" : 15
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "PingAction.java:45 - getAddress(return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/PingAction.java"
                },
                "region" : {
                  "startLine" : 45
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "PingAction.java:45 - Assignment to command"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/PingAction.java"
                },
                "region" : {
                  "startLine" : 45
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "PingAction.java:46 - exec(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/PingAction.java"
                },
                "region" : {
                  "startLine" : 46
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4356",
      "message" : {
        "text" : "The call to readLine() at PingAction.java line 52 might allow an attacker to crash the program or otherwise make it unavailable to legitimate users.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "FCAA83F93F95ABC9CEE6CE1E4A5C943F"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/appsecco/dvja/controllers/PingAction.java"
          },
          "region" : {
            "startLine" : 52,
            "endLine" : 52,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "PingAction.java:52 - readLine()"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/PingAction.java"
                },
                "region" : {
                  "startLine" : 52
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "PingAction.java:52 - readLine()"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/PingAction.java"
                },
                "region" : {
                  "startLine" : 52
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4355",
      "message" : {
        "text" : "The call to readLine() at PingAction.java line 59 might allow an attacker to crash the program or otherwise make it unavailable to legitimate users.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "FCAA83F93F95ABC9CEE6CE1E4A5C943E"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/appsecco/dvja/controllers/PingAction.java"
          },
          "region" : {
            "startLine" : 59,
            "endLine" : 59,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "PingAction.java:59 - readLine()"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/PingAction.java"
                },
                "region" : {
                  "startLine" : 59
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "PingAction.java:59 - readLine()"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/PingAction.java"
                },
                "region" : {
                  "startLine" : 59
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4352",
      "message" : {
        "text" : "Struts2 Actions should utilize the Struts Validation framework to prevent vulnerabilities that result from unchecked input.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F37D902FE731E75BAC2552AB489CF0F9"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/appsecco/dvja/controllers/ProductAction.java"
          },
          "region" : {
            "startLine" : 11,
            "endLine" : 11,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "ProductAction.java:11 - Class: ProductAction"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/ProductAction.java"
                },
                "region" : {
                  "startLine" : 11
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "ProductAction.java:11 - Class: ProductAction"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/ProductAction.java"
                },
                "region" : {
                  "startLine" : 11
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4300",
      "message" : {
        "text" : "The catch block at ProductAction.java line 89 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "0A55E71B873B79684AA6BC9750D4CEBB"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/appsecco/dvja/controllers/ProductAction.java"
          },
          "region" : {
            "startLine" : 89,
            "endLine" : 89,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "ProductAction.java:89 - CatchBlock"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/ProductAction.java"
                },
                "region" : {
                  "startLine" : 89
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "ProductAction.java:89 - CatchBlock"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/ProductAction.java"
                },
                "region" : {
                  "startLine" : 89
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4301",
      "message" : {
        "text" : "Struts2 Actions should utilize the Struts Validation framework to prevent vulnerabilities that result from unchecked input.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "17EC79C5744FAE22272C6D7198B47113"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/appsecco/dvja/controllers/RedirectAction.java"
          },
          "region" : {
            "startLine" : 5,
            "endLine" : 5,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "RedirectAction.java:5 - Class: RedirectAction"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/RedirectAction.java"
                },
                "region" : {
                  "startLine" : 5
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "RedirectAction.java:5 - Class: RedirectAction"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/RedirectAction.java"
                },
                "region" : {
                  "startLine" : 5
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4331",
      "message" : {
        "text" : "The catch block at Register.java line 88 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "96EC1700A732CDD6F8AC87E8F8B0F4A6"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/appsecco/dvja/controllers/Register.java"
          },
          "region" : {
            "startLine" : 88,
            "endLine" : 88,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "Register.java:88 - CatchBlock"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/Register.java"
                },
                "region" : {
                  "startLine" : 88
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "Register.java:88 - CatchBlock"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/Register.java"
                },
                "region" : {
                  "startLine" : 88
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4319",
      "message" : {
        "text" : "Struts2 Actions should utilize the Struts Validation framework to prevent vulnerabilities that result from unchecked input.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "5E4DF2EF8C888F6DFA97C0B957F84BE5"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/appsecco/dvja/controllers/ResetPassword.java"
          },
          "region" : {
            "startLine" : 6,
            "endLine" : 6,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "ResetPassword.java:6 - Class: ResetPassword"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/ResetPassword.java"
                },
                "region" : {
                  "startLine" : 6
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "ResetPassword.java:6 - Class: ResetPassword"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/ResetPassword.java"
                },
                "region" : {
                  "startLine" : 6
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4322",
      "message" : {
        "text" : "Storing passwords or password details in plain text anywhere in the system or system code may compromise system security in a way that cannot be easily remedied.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "6A308A8B5B632A509739A8C79FEFC0F4"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/appsecco/dvja/controllers/ResetPassword.java"
          },
          "region" : {
            "startLine" : 58,
            "endLine" : 58,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "ResetPassword.java:58 - Comment"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/ResetPassword.java"
                },
                "region" : {
                  "startLine" : 58
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "ResetPassword.java:58 - Comment"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/ResetPassword.java"
                },
                "region" : {
                  "startLine" : 58
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4315",
      "message" : {
        "text" : "The catch block at ResetPassword.java line 77 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "54ED032CBF0EA1F83665A6E3B5616396"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/appsecco/dvja/controllers/ResetPassword.java"
          },
          "region" : {
            "startLine" : 77,
            "endLine" : 77,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "ResetPassword.java:77 - CatchBlock"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/ResetPassword.java"
                },
                "region" : {
                  "startLine" : 77
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "ResetPassword.java:77 - CatchBlock"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/ResetPassword.java"
                },
                "region" : {
                  "startLine" : 77
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4328",
      "message" : {
        "text" : "Struts2 Actions should utilize the Struts Validation framework to prevent vulnerabilities that result from unchecked input.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "8CF9F9724D45A35960B497BE864D0EFF"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/appsecco/dvja/controllers/UserAction.java"
          },
          "region" : {
            "startLine" : 7,
            "endLine" : 7,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "UserAction.java:7 - Class: UserAction"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/UserAction.java"
                },
                "region" : {
                  "startLine" : 7
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "UserAction.java:7 - Class: UserAction"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/UserAction.java"
                },
                "region" : {
                  "startLine" : 7
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4351",
      "message" : {
        "text" : "The catch block at UserAction.java line 115 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F0D4FBB4B58E8832C40505D573758718"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/appsecco/dvja/controllers/UserAction.java"
          },
          "region" : {
            "startLine" : 115,
            "endLine" : 115,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "UserAction.java:115 - CatchBlock"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/UserAction.java"
                },
                "region" : {
                  "startLine" : 115
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "UserAction.java:115 - CatchBlock"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/controllers/UserAction.java"
                },
                "region" : {
                  "startLine" : 115
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4354",
      "message" : {
        "text" : "The method intercept() in AuthenticationInterceptor.java throws a generic exception making it harder for callers to do a good job of error handling and recovery.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F88D2FDE11E6BC2D97A2C5EADBEC645D"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/appsecco/dvja/interceptors/AuthenticationInterceptor.java"
          },
          "region" : {
            "startLine" : 15,
            "endLine" : 15,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "AuthenticationInterceptor.java:15 - Function: intercept"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/interceptors/AuthenticationInterceptor.java"
                },
                "region" : {
                  "startLine" : 15
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "AuthenticationInterceptor.java:15 - Function: intercept"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/interceptors/AuthenticationInterceptor.java"
                },
                "region" : {
                  "startLine" : 15
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4347",
      "message" : {
        "text" : "The method setTimestamps() in Product.java is not reachable from any method outside the class. It is dead code. Dead code is defined as code that is never directly or indirectly executed by a public method.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "CB467795FAB311085FA770F87C37DD67"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/appsecco/dvja/models/Product.java"
          },
          "region" : {
            "startLine" : 94,
            "endLine" : 94,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "Product.java:94 - Function: setTimestamps"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/models/Product.java"
                },
                "region" : {
                  "startLine" : 94
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "Product.java:94 - Function: setTimestamps"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/models/Product.java"
                },
                "region" : {
                  "startLine" : 94
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4359",
      "message" : {
        "text" : "A sensitive field defined in User.java on line 21 is exposed to the model binder.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "FEF2859639B1D1F00213E4DF1C9257EF"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/appsecco/dvja/models/User.java"
          },
          "region" : {
            "startLine" : 21,
            "endLine" : 21,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "User.java:21 - Field: role"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/models/User.java"
                },
                "region" : {
                  "startLine" : 21
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "User.java:21 - Field: role"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/models/User.java"
                },
                "region" : {
                  "startLine" : 21
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4349",
      "message" : {
        "text" : "The field createdAt is never used.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "D8BD2E8C095E7052BBFB2ECAEA37231C"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/appsecco/dvja/models/User.java"
          },
          "region" : {
            "startLine" : 34,
            "endLine" : 34,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "User.java:34 - Field: createdAt"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/models/User.java"
                },
                "region" : {
                  "startLine" : 34
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "User.java:34 - Field: createdAt"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/models/User.java"
                },
                "region" : {
                  "startLine" : 34
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4312",
      "message" : {
        "text" : "The field updatedAt is never used.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "46D0FAF0138E403208D7FCFB3919D41B"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/appsecco/dvja/models/User.java"
          },
          "region" : {
            "startLine" : 38,
            "endLine" : 38,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "User.java:38 - Field: updatedAt"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/models/User.java"
                },
                "region" : {
                  "startLine" : 38
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "User.java:38 - Field: updatedAt"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/models/User.java"
                },
                "region" : {
                  "startLine" : 38
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4345",
      "message" : {
        "text" : "The method setTimestamps() in User.java is not reachable from any method outside the class. It is dead code. Dead code is defined as code that is never directly or indirectly executed by a public method.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "C47DE0274E2DF9B3CB5771203FE5BA90"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/appsecco/dvja/models/User.java"
          },
          "region" : {
            "startLine" : 94,
            "endLine" : 94,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "User.java:94 - Function: setTimestamps"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/models/User.java"
                },
                "region" : {
                  "startLine" : 94
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "User.java:94 - Function: setTimestamps"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/dvja/models/User.java"
                },
                "region" : {
                  "startLine" : 94
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4357",
      "message" : {
        "text" : "Struts2 Actions should utilize the Struts Validation framework to prevent vulnerabilities that result from unchecked input.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "FD10023E2A00EAC1C7E48500D18B16D6"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/appsecco/example/ExampleSupport.java"
          },
          "region" : {
            "startLine" : 29,
            "endLine" : 29,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "ExampleSupport.java:29 - Class: ExampleSupport"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/example/ExampleSupport.java"
                },
                "region" : {
                  "startLine" : 29
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "ExampleSupport.java:29 - Class: ExampleSupport"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/example/ExampleSupport.java"
                },
                "region" : {
                  "startLine" : 29
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4304",
      "message" : {
        "text" : "Struts2 Actions should utilize the Struts Validation framework to prevent vulnerabilities that result from unchecked input.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "1E77E17D1C67D05A6C5401C0E8E88F08"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/appsecco/example/HelloWorld.java"
          },
          "region" : {
            "startLine" : 27,
            "endLine" : 27,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "HelloWorld.java:27 - Class: HelloWorld"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/example/HelloWorld.java"
                },
                "region" : {
                  "startLine" : 27
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "HelloWorld.java:27 - Class: HelloWorld"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/example/HelloWorld.java"
                },
                "region" : {
                  "startLine" : 27
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4348",
      "message" : {
        "text" : "The method execute() in HelloWorld.java throws a generic exception making it harder for callers to do a good job of error handling and recovery.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "D2000A8F6E5E4CB3478CEB658026ABE5"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/appsecco/example/HelloWorld.java"
          },
          "region" : {
            "startLine" : 29,
            "endLine" : 29,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "HelloWorld.java:29 - Function: execute"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/example/HelloWorld.java"
                },
                "region" : {
                  "startLine" : 29
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "HelloWorld.java:29 - Function: execute"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/example/HelloWorld.java"
                },
                "region" : {
                  "startLine" : 29
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4342",
      "message" : {
        "text" : "The method execute() in Login.java throws a generic exception making it harder for callers to do a good job of error handling and recovery.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "BB4890248C7A4E106498D2003F3C55AD"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/appsecco/example/Login.java"
          },
          "region" : {
            "startLine" : 26,
            "endLine" : 26,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "Login.java:26 - Function: execute"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/example/Login.java"
                },
                "region" : {
                  "startLine" : 26
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "Login.java:26 - Function: execute"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/java/com/appsecco/example/Login.java"
                },
                "region" : {
                  "startLine" : 26
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4332",
      "message" : {
        "text" : "A Struts2 validator is defined for an action field that does not exist.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "A038C3DA104795C1A4CF74955E157ABC"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/resources/com/appsecco/example/Login-validation.xml"
          },
          "region" : {
            "startLine" : 6,
            "endLine" : 6,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "Login-validation.xml:6"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/resources/com/appsecco/example/Login-validation.xml"
                },
                "region" : {
                  "startLine" : 6
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "Login-validation.xml:6"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/resources/com/appsecco/example/Login-validation.xml"
                },
                "region" : {
                  "startLine" : 6
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4302",
      "message" : {
        "text" : "Storing a plain text password in a configuration file may result in a system compromise.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "1B1FDA4A6A9C933BD42E3A4411FB544F"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/resources/com/appsecco/example/package.properties"
          },
          "region" : {
            "startLine" : 3,
            "endLine" : 3,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "package.properties:3 - password"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/resources/com/appsecco/example/package.properties"
                },
                "region" : {
                  "startLine" : 3
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "package.properties:3 - password"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/resources/com/appsecco/example/package.properties"
                },
                "region" : {
                  "startLine" : 3
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4299",
      "message" : {
        "text" : "Using wildcards (*) in Struts 2 action names enables evaluation of action names as OGNL expressions effectively enabling an attacker to modify system variables such as <code>Session</code> or execute arbitrary commands on the server.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "01B2AC68E4FADD79102D89E1C5782205"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/resources/example.xml"
          },
          "region" : {
            "startLine" : 23,
            "endLine" : 23,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "example.xml:23"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/resources/example.xml"
                },
                "region" : {
                  "startLine" : 23
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "example.xml:23"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/resources/example.xml"
                },
                "region" : {
                  "startLine" : 23
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4341",
      "message" : {
        "text" : "Application is deployed in Development Mode (devMode) allowing arbitrary command execution on the server and leaking detailed information about how the application is coded.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "BADBE2462CA5AC27347FED8D19C63693"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/resources/struts.xml"
          },
          "region" : {
            "startLine" : 7,
            "endLine" : 7,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "struts.xml:7"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/resources/struts.xml"
                },
                "region" : {
                  "startLine" : 7
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "struts.xml:7"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/resources/struts.xml"
                },
                "region" : {
                  "startLine" : 7
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4324",
      "message" : {
        "text" : "Storing a plain text password in a configuration file may result in a system compromise.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "7852C9684E0399E2AAA93461DD83E714"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/webapp/WEB-INF/config.properties"
          },
          "region" : {
            "startLine" : 4,
            "endLine" : 4,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "config.properties:4 - mysql.password"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/webapp/WEB-INF/config.properties"
                },
                "region" : {
                  "startLine" : 4
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "config.properties:4 - mysql.password"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/webapp/WEB-INF/config.properties"
                },
                "region" : {
                  "startLine" : 4
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4305",
      "message" : {
        "text" : "The form post at Login.jsp line 24 must contain a user-specific secret in order to prevent an attacker from making unauthorized requests.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "1FCC1E56FEB6B3696535A573237EC792"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/webapp/WEB-INF/dvja/Login.jsp"
          },
          "region" : {
            "startLine" : 24,
            "endLine" : 24,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "Login.jsp:24"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/webapp/WEB-INF/dvja/Login.jsp"
                },
                "region" : {
                  "startLine" : 24
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "Login.jsp:24"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/webapp/WEB-INF/dvja/Login.jsp"
                },
                "region" : {
                  "startLine" : 24
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4309",
      "message" : {
        "text" : "The form post at Ping.jsp line 20 must contain a user-specific secret in order to prevent an attacker from making unauthorized requests.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "390B3F841FB1997D52262A8F6003E92F"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/webapp/WEB-INF/dvja/Ping.jsp"
          },
          "region" : {
            "startLine" : 20,
            "endLine" : 20,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "Ping.jsp:20"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/webapp/WEB-INF/dvja/Ping.jsp"
                },
                "region" : {
                  "startLine" : 20
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "Ping.jsp:20"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/webapp/WEB-INF/dvja/Ping.jsp"
                },
                "region" : {
                  "startLine" : 20
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4314",
      "message" : {
        "text" : "The form post at ProductEdit.jsp line 24 must contain a user-specific secret in order to prevent an attacker from making unauthorized requests.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "48146F4AA788200C848FDF8398B6C1D0"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/webapp/WEB-INF/dvja/ProductEdit.jsp"
          },
          "region" : {
            "startLine" : 24,
            "endLine" : 24,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "ProductEdit.jsp:24"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/webapp/WEB-INF/dvja/ProductEdit.jsp"
                },
                "region" : {
                  "startLine" : 24
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "ProductEdit.jsp:24"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/webapp/WEB-INF/dvja/ProductEdit.jsp"
                },
                "region" : {
                  "startLine" : 24
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4335",
      "message" : {
        "text" : "A hidden form field is used in ProductEdit.jsp on line 26.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "A4F905DAC1673BD62CA51F88BA366C93"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/webapp/WEB-INF/dvja/ProductEdit.jsp"
          },
          "region" : {
            "startLine" : 26,
            "endLine" : 26,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "ProductEdit.jsp:26"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/webapp/WEB-INF/dvja/ProductEdit.jsp"
                },
                "region" : {
                  "startLine" : 26
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "ProductEdit.jsp:26"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/webapp/WEB-INF/dvja/ProductEdit.jsp"
                },
                "region" : {
                  "startLine" : 26
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4337",
      "message" : {
        "text" : "The form post at ProductList.jsp line 60 must contain a user-specific secret in order to prevent an attacker from making unauthorized requests.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "A6AC08FCC5A79936441489A8A47E66ED"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/webapp/WEB-INF/dvja/ProductList.jsp"
          },
          "region" : {
            "startLine" : 60,
            "endLine" : 60,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "ProductList.jsp:60"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/webapp/WEB-INF/dvja/ProductList.jsp"
                },
                "region" : {
                  "startLine" : 60
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "ProductList.jsp:60"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/webapp/WEB-INF/dvja/ProductList.jsp"
                },
                "region" : {
                  "startLine" : 60
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4308",
      "message" : {
        "text" : "The form post at Registration.jsp line 24 must contain a user-specific secret in order to prevent an attacker from making unauthorized requests.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "3186B9D5460F51CE8E9CBA615561D7E6"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/webapp/WEB-INF/dvja/Registration.jsp"
          },
          "region" : {
            "startLine" : 24,
            "endLine" : 24,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "Registration.jsp:24"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/webapp/WEB-INF/dvja/Registration.jsp"
                },
                "region" : {
                  "startLine" : 24
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "Registration.jsp:24"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/webapp/WEB-INF/dvja/Registration.jsp"
                },
                "region" : {
                  "startLine" : 24
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4307",
      "message" : {
        "text" : "The form post at ResetPasswordInput.jsp line 24 must contain a user-specific secret in order to prevent an attacker from making unauthorized requests.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "2BA169A83ED369B7A33D769A4CC4FBDD"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/webapp/WEB-INF/dvja/ResetPasswordInput.jsp"
          },
          "region" : {
            "startLine" : 24,
            "endLine" : 24,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "ResetPasswordInput.jsp:24"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/webapp/WEB-INF/dvja/ResetPasswordInput.jsp"
                },
                "region" : {
                  "startLine" : 24
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "ResetPasswordInput.jsp:24"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/webapp/WEB-INF/dvja/ResetPasswordInput.jsp"
                },
                "region" : {
                  "startLine" : 24
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4339",
      "message" : {
        "text" : "A hidden form field is used in ResetPasswordInput.jsp on line 34.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "B95EC8BFA534F48CD6DC5F0DB7BD250F"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/webapp/WEB-INF/dvja/ResetPasswordInput.jsp"
          },
          "region" : {
            "startLine" : 34,
            "endLine" : 34,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "ResetPasswordInput.jsp:34"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/webapp/WEB-INF/dvja/ResetPasswordInput.jsp"
                },
                "region" : {
                  "startLine" : 34
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "ResetPasswordInput.jsp:34"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/webapp/WEB-INF/dvja/ResetPasswordInput.jsp"
                },
                "region" : {
                  "startLine" : 34
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4340",
      "message" : {
        "text" : "A hidden form field is used in ResetPasswordInput.jsp on line 35.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "B95EC8BFA534F48CD6DC5F0DB7BD2510"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/webapp/WEB-INF/dvja/ResetPasswordInput.jsp"
          },
          "region" : {
            "startLine" : 35,
            "endLine" : 35,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "ResetPasswordInput.jsp:35"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/webapp/WEB-INF/dvja/ResetPasswordInput.jsp"
                },
                "region" : {
                  "startLine" : 35
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "ResetPasswordInput.jsp:35"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/webapp/WEB-INF/dvja/ResetPasswordInput.jsp"
                },
                "region" : {
                  "startLine" : 35
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4323",
      "message" : {
        "text" : "The form post at ResetPasswordStart.jsp line 24 must contain a user-specific secret in order to prevent an attacker from making unauthorized requests.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "735FCC38444C095798196AC03D6FDAB2"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/webapp/WEB-INF/dvja/ResetPasswordStart.jsp"
          },
          "region" : {
            "startLine" : 24,
            "endLine" : 24,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "ResetPasswordStart.jsp:24"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/webapp/WEB-INF/dvja/ResetPasswordStart.jsp"
                },
                "region" : {
                  "startLine" : 24
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "ResetPasswordStart.jsp:24"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/webapp/WEB-INF/dvja/ResetPasswordStart.jsp"
                },
                "region" : {
                  "startLine" : 24
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4353",
      "message" : {
        "text" : "The form post at UserEdit.jsp line 21 must contain a user-specific secret in order to prevent an attacker from making unauthorized requests.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F3F2711DFA11EB2716262F1C6823A3C8"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/webapp/WEB-INF/dvja/UserEdit.jsp"
          },
          "region" : {
            "startLine" : 21,
            "endLine" : 21,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "UserEdit.jsp:21"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/webapp/WEB-INF/dvja/UserEdit.jsp"
                },
                "region" : {
                  "startLine" : 21
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "UserEdit.jsp:21"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/webapp/WEB-INF/dvja/UserEdit.jsp"
                },
                "region" : {
                  "startLine" : 21
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4313",
      "message" : {
        "text" : "A hidden form field is used in UserEdit.jsp on line 22.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "47EEB7D3C816D74B7099C0EE556E45AA"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/webapp/WEB-INF/dvja/UserEdit.jsp"
          },
          "region" : {
            "startLine" : 22,
            "endLine" : 22,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "UserEdit.jsp:22"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/webapp/WEB-INF/dvja/UserEdit.jsp"
                },
                "region" : {
                  "startLine" : 22
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "UserEdit.jsp:22"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/webapp/WEB-INF/dvja/UserEdit.jsp"
                },
                "region" : {
                  "startLine" : 22
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4318",
      "message" : {
        "text" : "The form post at UserSearch.jsp line 21 must contain a user-specific secret in order to prevent an attacker from making unauthorized requests.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "592B0DD2D4A96EE1F188970758EDA711"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/webapp/WEB-INF/dvja/UserSearch.jsp"
          },
          "region" : {
            "startLine" : 21,
            "endLine" : 21,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "UserSearch.jsp:21"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/webapp/WEB-INF/dvja/UserSearch.jsp"
                },
                "region" : {
                  "startLine" : 21
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "UserSearch.jsp:21"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/webapp/WEB-INF/dvja/UserSearch.jsp"
                },
                "region" : {
                  "startLine" : 21
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4329",
      "message" : {
        "text" : "Any information revealed in the HTML comment at Footer.jsp line 17 could help an adversary learn about the system and form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "8E5F76C9D7D6691AD337CB3D264002AB"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/webapp/WEB-INF/dvja/common/Footer.jsp"
          },
          "region" : {
            "startLine" : 17,
            "endLine" : 17,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "Footer.jsp:17 - Comment"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/webapp/WEB-INF/dvja/common/Footer.jsp"
                },
                "region" : {
                  "startLine" : 17
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "Footer.jsp:17 - Comment"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/webapp/WEB-INF/dvja/common/Footer.jsp"
                },
                "region" : {
                  "startLine" : 17
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4321",
      "message" : {
        "text" : "Any information revealed in the HTML comment at Head.jsp line 5 could help an adversary learn about the system and form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "64F8FD3C5EC4F9EDBF4E5094E2923346"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/webapp/WEB-INF/dvja/common/Head.jsp"
          },
          "region" : {
            "startLine" : 5,
            "endLine" : 5,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "Head.jsp:5 - Comment"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/webapp/WEB-INF/dvja/common/Head.jsp"
                },
                "region" : {
                  "startLine" : 5
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "Head.jsp:5 - Comment"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/webapp/WEB-INF/dvja/common/Head.jsp"
                },
                "region" : {
                  "startLine" : 5
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4338",
      "message" : {
        "text" : "The file Head.jsp references a script using a hardcoded domain name on line 7. If attackers compromise the domain, they will have malicious code on this page.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "B42D3BC345715BC780882BE260A4595B"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/webapp/WEB-INF/dvja/common/Head.jsp"
          },
          "region" : {
            "startLine" : 7,
            "endLine" : 7,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "Head.jsp:7"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/webapp/WEB-INF/dvja/common/Head.jsp"
                },
                "region" : {
                  "startLine" : 7
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "Head.jsp:7"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/webapp/WEB-INF/dvja/common/Head.jsp"
                },
                "region" : {
                  "startLine" : 7
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4350",
      "message" : {
        "text" : "The file Head.jsp on line 7 loads a script over an unencrypted channel.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "E275D60D42B32BAB6E53FE531B8E3F26"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/webapp/WEB-INF/dvja/common/Head.jsp"
          },
          "region" : {
            "startLine" : 7,
            "endLine" : 7,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "Head.jsp:7"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/webapp/WEB-INF/dvja/common/Head.jsp"
                },
                "region" : {
                  "startLine" : 7
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "Head.jsp:7"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/webapp/WEB-INF/dvja/common/Head.jsp"
                },
                "region" : {
                  "startLine" : 7
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4325",
      "message" : {
        "text" : "Any information revealed in the HTML comment at Navigation.jsp line 37 could help an adversary learn about the system and form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "7A47D2D51B2E8B627C8C43E37B499C6A"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/webapp/WEB-INF/dvja/common/Navigation.jsp"
          },
          "region" : {
            "startLine" : 37,
            "endLine" : 37,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "Navigation.jsp:37 - Comment"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/webapp/WEB-INF/dvja/common/Navigation.jsp"
                },
                "region" : {
                  "startLine" : 37
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "Navigation.jsp:37 - Comment"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/webapp/WEB-INF/dvja/common/Navigation.jsp"
                },
                "region" : {
                  "startLine" : 37
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4306",
      "message" : {
        "text" : "The form post at Login.jsp line 9 must contain a user-specific secret in order to prevent an attacker from making unauthorized requests.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "1FCC1E56FEB6B3696535A573237EC793"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/webapp/WEB-INF/example/Login.jsp"
          },
          "region" : {
            "startLine" : 9,
            "endLine" : 9,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "Login.jsp:9"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/webapp/WEB-INF/example/Login.jsp"
                },
                "region" : {
                  "startLine" : 9
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "Login.jsp:9"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/webapp/WEB-INF/example/Login.jsp"
                },
                "region" : {
                  "startLine" : 9
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4310",
      "message" : {
        "text" : "A web application must define default error pages in order to prevent attackers from mining information from the application container's built-in error response.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "399A248E35AE0FBB04255DE45FA9754C"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/webapp/WEB-INF/web.xml"
          },
          "region" : {
            "startLine" : 5,
            "endLine" : 5,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "web.xml:5 - /web-app"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/webapp/WEB-INF/web.xml"
                },
                "region" : {
                  "startLine" : 5
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "web.xml:5 - /web-app"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/webapp/WEB-INF/web.xml"
                },
                "region" : {
                  "startLine" : 5
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "4343",
      "message" : {
        "text" : "An overly long session timeout gives attackers more time to potentially compromise user accounts.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "C2F39B963AB1AFACD8D57325EEAF747F"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/webapp/WEB-INF/web.xml"
          },
          "region" : {
            "startLine" : 5,
            "endLine" : 5,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "web.xml:5"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/webapp/WEB-INF/web.xml"
                },
                "region" : {
                  "startLine" : 5
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "web.xml:5"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "src/main/webapp/WEB-INF/web.xml"
                },
                "region" : {
                  "startLine" : 5
                }
              }
            }
          } ]
        } ]
      } ]
    } ]
  } ]
}